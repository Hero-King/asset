机器语言上面的最底层语言

参考笔记 ： https://fishc.com.cn/thread-7043-1-1.html

### 介绍
#### 计算机组成原理

计算机发展史: 
- 电子管时代   笨重 速度慢  电子管是可见的(so big) 第一台计算机是二战期间为了计算导弹飞机的运行轨迹
- 晶体管时代    瘦小 贝尔实验室的三个科学家发明了晶体管 第一次装备了显示器
- 集成电路   近代计算机
- 超大规模继承电路计算机  多核CPU

计算机体系结构
冯诺依曼 将程序指令和数据一起存储的计算机设计概念结构(把程序存储起来并设计通用电路)   解决了一台计算机执行不同程序需要设计不同电路的问题
运算器 控制器 存储器 输入 输出

计算机总线:  
- 片内总线 :  芯片内部的总线;寄存器与寄存器之间;寄存器与控制器、运算器之间   -- 高集成度芯片内部的信息传输线
- 系统总线: CPU 主存 硬盘 IO设备 USB PCI插槽 显卡声卡 等设备的信息传输总线 -- 分成三大类(数据 地址 控制)
怎么设计的  就和网络结构中的 直线型 一样  系统总线如下
   CPU          主存
    |           |
-------总线总线总线总线总线总线总线总线总线总线总线-----
        |     |         |        |          |
      键盘   鼠标      硬盘      USB插槽   PCI等

总线仲裁(和计算机发送数据一样CSMA/CD): 仲裁控制器(分析设备使用总线优先级)
比如主存要和键盘和鼠标交换数据,谁占用总线呢?? 解决总线使用权冲突问题
方法: 
- 链式查询 连接到总线上的设备通过允许使用线连接,A设备不使用总线,就会允许下一个设备使用总线 (电路复杂度低，仲裁方式简单, 优先级低的设备难以获得总线使用权, 对电路故障敏感)
- 计数器定时查询 仲裁控制器接收到信号之后,给总线中发送允许获取总线权的设备号 从0开始,0设备接收到判断是不是自己发的请求,不是就告诉仲裁器不是我的 计数器+1  发送1给总线
- 独立请求 

计算机的输入输出设备
输入: 
- 字符输入设备
- 图像输入设备

CPU和IO设备通信方式
输入输出设备触发程序中断信号给CPU CPU转去执行指定的中断处理代码,执行完成再继续之前的操作
外部设备提供通知CPU的一种异步的方式,CPU高速运转的同时兼顾低速设备的响应
但是老是打断CPU也不是办法,出现了DMA 在主存和IO设备之间,控制主存和外部设备的交互

计算机存储
缓存(CPU高速缓存/寄存器)
主存 各种设备的RAM
辅村(磁盘 U盘)
   ________________
  |                |
CPU----高速缓存----主存----辅存
  |                 |
  ------------------

都是使用局部性原理
高速缓存存储数据
字(字长,字占多少位)  字块(由多个字组成)  
字的地址两部分
前m位指定字块的地址;后b位指定字在字块中的地址
高速缓存的性能指标,命中率   高速缓存的替换策略 
- 随机置换
- FIFO 先进先出
- LFU 最不经常使用 需要额外空间记录使用频率
- LRU 最近最少使用 多种实现方式,一般使用双向链表 最新使用的放入链表头,或者已经存在链表中的提到最前面

机器指令: 
形式: 操作码(进行哪种操作)+地址码(给出操作数或者操作数的地址,可能出现1个地址,2个地址,三个地址)
三地址指令: 操作指令OP 地址1 地址2 地址三   比如1 + 2 结果放到3中 
二地址指令: 两个操作数结果放到某个地址中
一地址指令: 自己对自己操作
零地址指令:   空操作  停机操作  中断返回操作  

操作类型: 
数据传输 算数逻辑操作 移位操作 控制指令
机器指令的寻址方式: 
顺序寻址: CPU执行的指令是按照程序的生成的指令的顺序执行的
跳跃寻址: JMP 调到某个地方去执行
数据寻址方式: 

指令执行过程:
取指令  -- 分析指令 --执行指令
指令和数据缓存到CPU的高速缓存 程序计数器指向第一个要执行的指令地址,取出指令操作码地址码需要取数据的话导数据缓存中/地址总线的主存中取 到指令寄存器 发送到指令译码器 同时指令计数器指向下一条指令的起始地址 译码器翻译发送控制信号给运算器 数据装载到寄存器 ALU计算数据, 状态寄存器记录运算状态,如果进位,或者溢出记录, 送出运算结果
https://www.bilibili.com/video/BV1zW411n79C?p=10
https://www.bilibili.com/video/BV1rV411k7Xf?p=17
控制器和运算器并没有同时工作,效率低
有了CPU流水线设计: 分析执行同时取指令分析






### 汇编语言
编程语言是汇编语言 ; 汇编语言可以翻译成可直接执行的机器语言;  完成翻译的过程的程序就是汇编器
汇编指令是及其指令便于记忆的书写方式
汇编指令和机器指令是一对一的关系   所有可以通过汇编进行反编译

汇编指令：
MOV AX BX     寄存器BX内容送到AX寄存器（CPU里面可以存储数据的器件，比二级缓存低）中

汇编语言的组成： 
- 汇编指令
- 伪指令（由编译器执行）
- 其他符号（编译器识别  + - * / 等）

存储器 CPU是计算机的核心，但是想让CPU工作，必须向他提供指令和数据（存放在存储器中--内存/显存/网卡存储/BIOS存...设备都是有内存的）
指令和数据都是二进制信息，把一个二进制数据可以看成是数据，也可以是指令
比如： 1000100111011000    数据： 89D8H 指令：MOV AX，BX
我们指定这个二进制信息是什么就是什么

CPU进行数据读写时，必须和外部芯片（各种内存）进行3类信息交换：
1.地址信息 即地址总线    寻找数据在存储设备的位置
2.控制信息 即控制总线   对外部设备的控制 控制总线是用来发出各种控制信号的传输线, 控制信号经由控制总线从一个组件发给另外一个组件(CPU发给内存等),控制总线可以监视不同组件之间的状态（就绪/未就绪）
3.数据信息 即数据总线   把数据传递到CPU中  一个整型数据占用4字节
CPU 发出读写某块地址的地址信息给地址总线，给控制总线发送是读操作还是写操作，和控制哪块设备，然后数据就从数据总线传递到CPU里面某块地址上/CPU把数据写入到那块地址上

也就是说地址总线里面的二进制数据表示地址，数据总线里面的表示数据，控制总线里面的表示控制的语句

BIOS是主板和各类接口卡（显卡网卡等）厂商提供的软件系统，存储在ROM中  接口卡也有BIOS RAM ROM

内存地址空间： CPU将各类存储器看作一个逻辑存储器，所有的设备接口卡内存组成一个大的内存空间

### 寄存器（CPU互作原理）
CPU 内部： 运算器 控制器 寄存器   使用内部总线连接   CPU连接外部器件是外部总线(三大类的那个)
寄存器 > 缓存 》 二级缓存 》 
CPU要取数据，处bai理数据，都要放到du寄存器处zhi理。一般寄存器不用太dao大，它只要存放zhuan指令一次操作的shu数据就够了。
高速缓存是内存的部分拷贝，因为高速缓存速度快，把常用的数据放这里可以提高速度。
高速缓存一般不能被程序直接更改，它由硬件自己处理。程序直接读写CPU的寄存器，来完成操作。
一般两者都集成在CPU上。

寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果  把111放在AX 222放在BX  运算器命令 ax + bx 放在CX 中

8086CPU  14个寄存器 都是16位 存放两个字节 就是一个字  其中8个通用寄存器  
通用寄存器AX BX CX DX  这四个寄存器为了兼容之前的*位寄存器,可以拆开独立使用  AH AL
8086CPU把地址线 控制线 数据线都从8位升成16位 所以一次可以读取两个字节  就是一个字存放在寄存器中

几条汇编指令:
不分大小写 ; 
MOV ax,18  把18放入ax寄存器       高级语言表示:  AX = 18
ADD ax,8   ax寄存器数值+8                       AX = AX + 8
MOV ax,bx  把bx数据送入ax中
ADD ax,bx  把ax + bx 放入 ax

CPU访问内存单元时要给出内存单元的地址,所有的内存单元构成的存储单元空间是一个一维的线性空间
16位CPU 具有以下性质:
运算器ALU一次最多处理16位数据   寄存器最大宽度16位 寄存器和运算器之间的通路是16位
8086CPU的地址总线是20位,能够遍历的地址是2的20次方  但是内部是16位的,只能遍历16位的地址,那么多出来的地址怎么表示呢?
内部使用两个16位表示表示20位物理地址  段地址+偏移地址的方式
段地址 偏移地址 传送到地址加法器 生成20位物理地址= 段地址*16 + 偏移地址  也就是段地址左移1位
内存被划分成一个一个段??  没有,只是CPU的不足人为加入段
CPU可以用不同的段地址 + 偏移地址找到同一个物理地址
数据在21F60H地址中   == 数据在内存2000:1F60单元中 == 数据在内存2000段1F60中
段地址存放在段寄存器 CS代码段寄存器  DS 数据段寄存器 SS 堆栈段寄存器 ES 额外的段地址
IP 偏移地址寄存器
CS + ip 指定CPU当前要读取的指令的地址 

#### 8086CPU执行指令: 
CS+ip寄存器里面的地址数据传入到 地址加法器 得到真实的物理地址, 通过控制器 送上地址总线,取得指令(操作码+地址码) 送入数据总线传入指令寄存器 译码器 计算

8086CPU加电或者复位时候,CS设置FFFF IP设置0000, CPU从内存FFFF0H单元读取指令执行第一条指令
程序员只能通过改变CS IP寄存器的内容实现对CPU的控制!!
使用mov 关键词不能改变这两个寄存器  而是通过  JMP 加以区分  (JMP 段地址:偏移地址)
仅修改IP寄存器   JMP ax    类似 mov ip ax
在编程时候,可以将长度为N (N<=64KB) 的一组代码存放在连续的起始地址为16的倍数的内存单元中(这样可以通过一个段地址+ 偏移地址找到), 从而定义了一个代码段
比如: MOV ax 0000   机器指令(B8 00 00)
      ad ax 0123           (05 23 01)
      mv bx ax             (8b d8)
      jmp bx                (ff e3)         占用10个字节 存放在某一块连续的地址中,这就是代码段
怎么执行这个代码段呢??   是不是把CS+ip指向首地指就可以了 对的
CPU只认被CS+ ip指向的内存单元中的内容当做指令来执行  如果是DS指向的 CPU当做是数据而不当做指令去执行  
### 寄存器(内存访问)
任何两个连续的内存单元,N单元和N+1单元,可以看成一个地址为N的字单元中的高低位
CPU要读取内存单元的时候,必须知道内存单元的地址,由段地址和偏移地址组成
DS 寄存器存放要读取数据的段地址
MOV  al [0]  把内存单元的偏移地址的内容放入寄存器  那么段地址哪里来的呢?  就是DS 里面的数据  只能把通用寄存器的数据mov进去DS 不能直接MOV数据进去

怎么把数据从内存中送入寄存器??  mov Ax  1000H 
怎么把数据从寄存器送入内存单元?? mov bx 1000H   mov ds bx; mov [0] ax(把ax寄存器的16位数据送入1000:0 处高位1000:1 低位1000:0); 
因为8086CPU是16位的数据总线,一次性可传输16位数据,一个字
mov bx 1000H ; mov ds bx; mov ax [0]  把1000:0处的字型数据送入ax  两个字节的数据哦  因为ax是16位的  取得数据也就是16位的
add bx [1] ; 也是把1001 和1002地址的16位数据与bx相加给bx   
命令后面的寄存器是16位的  那么偏移地址也看成16位 

#### mov add sub



