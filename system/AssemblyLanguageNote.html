<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.24" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.94" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"汇编","image":[""],"dateModified":"2025-11-22T10:49:26.000Z","author":[{"@type":"Person","name":"HeroKing","url":"https://github.com/Hero-King","email":"838774057@qq.com"}]}</script><meta property="og:url" content="https://blog.heroking.top/system/AssemblyLanguageNote.html"><meta property="og:site_name" content="HeroKing博客"><meta property="og:title" content="汇编"><meta property="og:description" content="汇编 机器语言上面的最底层语言 参考笔记 ： https://fishc.com.cn/thread-7043-1-1.html 计算机组成原理 计算机发展史: 电子管时代 笨重 速度慢 电子管是可见的(so big) 第一台计算机是二战期间为了计算导弹飞机的运行轨迹 晶体管时代 瘦小 贝尔实验室的三个科学家发明了晶体管 第一次装备了显示器 集成电路 ..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-11-22T10:49:26.000Z"><meta property="article:modified_time" content="2025-11-22T10:49:26.000Z"><link rel="icon" href="/favicon.ico"><title>汇编 | HeroKing博客</title><meta name="description" content="汇编 机器语言上面的最底层语言 参考笔记 ： https://fishc.com.cn/thread-7043-1-1.html 计算机组成原理 计算机发展史: 电子管时代 笨重 速度慢 电子管是可见的(so big) 第一台计算机是二战期间为了计算导弹飞机的运行轨迹 晶体管时代 瘦小 贝尔实验室的三个科学家发明了晶体管 第一次装备了显示器 集成电路 ...">
    <link rel="preload" href="/assets/style-LUTMIi_g.css" as="style"><link rel="stylesheet" href="/assets/style-LUTMIi_g.css">
    <link rel="modulepreload" href="/assets/app-CPWYzFNH.js"><link rel="modulepreload" href="/assets/AssemblyLanguageNote.html-B_T_lJhY.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-gbUhQ8Hc.js" as="script"><link rel="prefetch" href="/assets/intro.html-oJwwsLN9.js" as="script"><link rel="prefetch" href="/assets/C__.html-9W6pGvWn.js" as="script"><link rel="prefetch" href="/assets/ocr.html-DF2317if.js" as="script"><link rel="prefetch" href="/assets/index.html-CCaLZl7e.js" as="script"><link rel="prefetch" href="/assets/xiaoai.html-E_XlFwFq.js" as="script"><link rel="prefetch" href="/assets/HighPerformanceBrowserNetworking.html-pfml6Msc.js" as="script"><link rel="prefetch" href="/assets/deepUnderstandJavaScript.html-D7uDhNxo.js" as="script"><link rel="prefetch" href="/assets/index.html-A9iy82jf.js" as="script"><link rel="prefetch" href="/assets/FullStackDeveloper.html-CLJWem_h.js" as="script"><link rel="prefetch" href="/assets/index.html-WzzzLr7w.js" as="script"><link rel="prefetch" href="/assets/camera.html-Cp_GHqPJ.js" as="script"><link rel="prefetch" href="/assets/car.html-DnglCzru.js" as="script"><link rel="prefetch" href="/assets/excel.html-Db9ikgps.js" as="script"><link rel="prefetch" href="/assets/nas.html-D8SivNYs.js" as="script"><link rel="prefetch" href="/assets/index.html-B2kLw2-3.js" as="script"><link rel="prefetch" href="/assets/DDNS.html-l3Kzv8fz.js" as="script"><link rel="prefetch" href="/assets/http.html-Dkz8SwDT.js" as="script"><link rel="prefetch" href="/assets/https.html-C6U5FaC9.js" as="script"><link rel="prefetch" href="/assets/iptv.html-DOfbC8z9.js" as="script"><link rel="prefetch" href="/assets/modem.html-CeqveaEq.js" as="script"><link rel="prefetch" href="/assets/proxy.html-DUbTeqkc.js" as="script"><link rel="prefetch" href="/assets/index.html-BW8Idl4X.js" as="script"><link rel="prefetch" href="/assets/ESXI.html-qaFm_2Gr.js" as="script"><link rel="prefetch" href="/assets/RemoteDesktop.html-CIDJQicr.js" as="script"><link rel="prefetch" href="/assets/ftp.html-BVPHuVfi.js" as="script"><link rel="prefetch" href="/assets/index.html-5S7SHOWS.js" as="script"><link rel="prefetch" href="/assets/samba.html-DmzBZLdp.js" as="script"><link rel="prefetch" href="/assets/vscode.html-C8-OaC6n.js" as="script"><link rel="prefetch" href="/assets/webhook.html-Cn2zXYXd.js" as="script"><link rel="prefetch" href="/assets/T1.html-BWj-k6tm.js" as="script"><link rel="prefetch" href="/assets/fn.html-lODCwcv1.js" as="script"><link rel="prefetch" href="/assets/openwrt.html-CK-WsSut.js" as="script"><link rel="prefetch" href="/assets/os.html-CCnYmvXR.js" as="script"><link rel="prefetch" href="/assets/pve.html-B2Hz-dgk.js" as="script"><link rel="prefetch" href="/assets/index.html-CaC3BEwG.js" as="script"><link rel="prefetch" href="/assets/activeMq.html-jZjUOxqd.js" as="script"><link rel="prefetch" href="/assets/index.html-BKwIPe58.js" as="script"><link rel="prefetch" href="/assets/index.html-D6g1IDJh.js" as="script"><link rel="prefetch" href="/assets/index.html-Dvls2YSa.js" as="script"><link rel="prefetch" href="/assets/index.html-BReVvvA_.js" as="script"><link rel="prefetch" href="/assets/index.html-Da94UzK1.js" as="script"><link rel="prefetch" href="/assets/index.html-CAnFpGSp.js" as="script"><link rel="prefetch" href="/assets/ChromeDebugg.html-ng0dE5qB.js" as="script"><link rel="prefetch" href="/assets/H5.html-DYXCL9LK.js" as="script"><link rel="prefetch" href="/assets/compressImage.html-Dd3ZeOOC.js" as="script"><link rel="prefetch" href="/assets/echarts.html-Bm82ERMt.js" as="script"><link rel="prefetch" href="/assets/glsl.html-C64-tkaF.js" as="script"><link rel="prefetch" href="/assets/index.html-Bu72A4X0.js" as="script"><link rel="prefetch" href="/assets/thingjs.html-CbBazj7n.js" as="script"><link rel="prefetch" href="/assets/npm.html-DsM-pUQg.js" as="script"><link rel="prefetch" href="/assets/index.html-DPrwMGol.js" as="script"><link rel="prefetch" href="/assets/vite.html-CSmJT8dE.js" as="script"><link rel="prefetch" href="/assets/vuecli.html-Ctnz6hWA.js" as="script"><link rel="prefetch" href="/assets/index.html-BQIgeTVX.js" as="script"><link rel="prefetch" href="/assets/Nestjs.html-BeD-gLKW.js" as="script"><link rel="prefetch" href="/assets/puppeteer.html-C1qyqvYr.js" as="script"><link rel="prefetch" href="/assets/index.html-DIMWmMJJ.js" as="script"><link rel="prefetch" href="/assets/typeorm.html-a6jqLClP.js" as="script"><link rel="prefetch" href="/assets/index.html-DC_PAlMB.js" as="script"><link rel="prefetch" href="/assets/uniapp.html-BuJuw82J.js" as="script"><link rel="prefetch" href="/assets/monitor.html-Dygyx25r.js" as="script"><link rel="prefetch" href="/assets/index.html-DgNPojuE.js" as="script"><link rel="prefetch" href="/assets/github.html-DJSb2_p0.js" as="script"><link rel="prefetch" href="/assets/project.html-BQ3kWdls.js" as="script"><link rel="prefetch" href="/assets/index.html-Cpl1pHPl.js" as="script"><link rel="prefetch" href="/assets/index.html-Ia-9VKpC.js" as="script"><link rel="prefetch" href="/assets/mac.html-Cunw63pu.js" as="script"><link rel="prefetch" href="/assets/index.html-BH1PUXCq.js" as="script"><link rel="prefetch" href="/assets/commandList.html-DjEm8geY.js" as="script"><link rel="prefetch" href="/assets/cron.html-CJ5MBspd.js" as="script"><link rel="prefetch" href="/assets/index.html-dhc8THY3.js" as="script"><link rel="prefetch" href="/assets/index.html-DItzQnd7.js" as="script"><link rel="prefetch" href="/assets/bat.html-Bn-1fqWU.js" as="script"><link rel="prefetch" href="/assets/vbs.html-nxrZNz4v.js" as="script"><link rel="prefetch" href="/assets/index.html-B6y6zwOx.js" as="script"><link rel="prefetch" href="/assets/index.html-BxK3AjqR.js" as="script"><link rel="prefetch" href="/assets/index.html-BldO8SS7.js" as="script"><link rel="prefetch" href="/assets/404.html-B5GXHWWN.js" as="script"><link rel="prefetch" href="/assets/index.html-DyoLNpqM.js" as="script"><link rel="prefetch" href="/assets/index.html-Rd51-6Rl.js" as="script"><link rel="prefetch" href="/assets/index.html-Dg_Tf6SU.js" as="script"><link rel="prefetch" href="/assets/index.html-CQo01TeF.js" as="script"><link rel="prefetch" href="/assets/index.html-DMr4fEcJ.js" as="script"><link rel="prefetch" href="/assets/index.html-D7WwFlJK.js" as="script"><link rel="prefetch" href="/assets/index.html-DQSjskv8.js" as="script"><link rel="prefetch" href="/assets/flowchart-G1WAoCnn.js" as="script"><link rel="prefetch" href="/assets/index-DtWMYcbt.js" as="script"><link rel="prefetch" href="/assets/index-DMDrkyre.js" as="script"><link rel="prefetch" href="/assets/index-BPAdBlYL.js" as="script"><link rel="prefetch" href="/assets/mermaid.esm.min-CjstNU05.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-CKV1Bsxh.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="带我回家"><img class="vp-nav-logo" src="https://theme-hope-assets.vuejs.press/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">HeroKing博客</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="博客主页"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" sizing="height" height="1em"></iconify-icon><!--]-->博客主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/frontEnd/" aria-label="前端"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:code" sizing="height" height="1em"></iconify-icon><!--]-->前端<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/afterEnd/" aria-label="后端"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:database" sizing="height" height="1em"></iconify-icon><!--]-->后端<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/algorithms/" aria-label="数据结构与算法"><!---->数据结构与算法<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/network/" aria-label="网络"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:network-wired" sizing="height" height="1em"></iconify-icon><!--]-->网络<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/software/" aria-label="软件"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:software" sizing="height" height="1em"></iconify-icon><!--]-->软件<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/system/" aria-label="操作系统"><!---->操作系统<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/books/" aria-label="Books"><!---->Books<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/Hero-King/asset" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/system/fn.html" aria-label="FnOS"><!---->FnOS<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Hackintosh</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Linux</span><span class="vp-arrow end"></span></button><!----></section></li><li><a class="route-link auto-link vp-sidebar-link" href="/system/openwrt.html" aria-label="openwrt"><!---->openwrt<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/system/pve.html" aria-label="PVE"><!---->PVE<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/system/T1.html" aria-label="T1"><!---->T1<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">win10 系统</span><span class="vp-arrow end"></span></button><!----></section></li><li><a class="route-link auto-link vp-sidebar-link" href="/system/os.html" aria-label="操作系统介绍"><!---->操作系统介绍<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/system/AssemblyLanguageNote.html" aria-label="汇编"><!---->汇编<!----></a></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->汇编</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/Hero-King" target="_blank" rel="noopener noreferrer">HeroKing</a></span><span property="author" content="HeroKing"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025/11/22</span><meta property="datePublished" content="2025-11-22T10:49:26.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 22 分钟</span><meta property="timeRequired" content="PT22M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><h1 id="汇编" tabindex="-1"><a class="header-anchor" href="#汇编"><span>汇编</span></a></h1><p>机器语言上面的最底层语言</p><p>参考笔记 ： <a href="https://fishc.com.cn/thread-7043-1-1.html" target="_blank" rel="noopener noreferrer">https://fishc.com.cn/thread-7043-1-1.html</a></p><h2 id="计算机组成原理" tabindex="-1"><a class="header-anchor" href="#计算机组成原理"><span>计算机组成原理</span></a></h2><p>计算机发展史:</p><ul><li>电子管时代 笨重 速度慢 电子管是可见的(so big) 第一台计算机是二战期间为了计算导弹飞机的运行轨迹</li><li>晶体管时代 瘦小 贝尔实验室的三个科学家发明了晶体管 第一次装备了显示器</li><li>集成电路 近代计算机</li><li>超大规模继承电路计算机 多核 CPU</li></ul><p>计算机体系结构<br> 冯诺依曼 将程序指令和数据一起存储的计算机设计概念结构(把程序存储起来并设计通用电路) 解决了一台计算机执行不同程序需要设计不同电路的问题<br> 运算器 控制器 存储器 输入 输出</p><p>计算机总线:</p><ul><li>片内总线 : 芯片内部的总线;寄存器与寄存器之间;寄存器与控制器、运算器之间 -- 高集成度芯片内部的信息传输线</li><li>系统总线: CPU 主存 硬盘 IO 设备 USB PCI 插槽 显卡声卡 等设备的信息传输总线 -- 分成三大类(数据 地址 控制)<br> 怎么设计的 就和网络结构中的 直线型 一样 系统总线如下<br> CPU 主存<br> | |<br> -------总线总线总线总线总线总线总线总线总线总线总线-----<br> | | | | |<br> 键盘 鼠标 硬盘 USB 插槽 PCI 等</li></ul><p>总线仲裁(和计算机发送数据一样 CSMA/CD): 仲裁控制器(分析设备使用总线优先级)<br> 比如主存要和键盘和鼠标交换数据,谁占用总线呢?? 解决总线使用权冲突问题<br> 方法:</p><ul><li>链式查询 连接到总线上的设备通过允许使用线连接,A 设备不使用总线,就会允许下一个设备使用总线 (电路复杂度低，仲裁方式简单, 优先级低的设备难以获得总线使用权, 对电路故障敏感)</li><li>计数器定时查询 仲裁控制器接收到信号之后,给总线中发送允许获取总线权的设备号 从 0 开始,0 设备接收到判断是不是自己发的请求,不是就告诉仲裁器不是我的 计数器+1 发送 1 给总线</li><li>独立请求</li></ul><p>计算机的输入输出设备<br> 输入:</p><ul><li>字符输入设备</li><li>图像输入设备</li></ul><p>CPU 和 IO 设备通信方式<br> 输入输出设备触发程序中断信号给 CPU CPU 转去执行指定的中断处理代码,执行完成再继续之前的操作<br> 外部设备提供通知 CPU 的一种异步的方式,CPU 高速运转的同时兼顾低速设备的响应<br> 但是老是打断 CPU 也不是办法,出现了 DMA 在主存和 IO 设备之间,控制主存和外部设备的交互</p><p>计算机存储<br> 缓存(CPU 高速缓存/寄存器)<br> 主存 各种设备的 RAM<br> 辅村(磁盘 U 盘)</p><hr><p>| |<br> CPU----高速缓存----主存----辅存<br> | |</p><hr><p>都是使用局部性原理<br> 高速缓存存储数据<br> 字(字长,字占多少位) 字块(由多个字组成)<br> 字的地址两部分<br> 前 m 位指定字块的地址;后 b 位指定字在字块中的地址<br> 高速缓存的性能指标,命中率 高速缓存的替换策略</p><ul><li>随机置换</li><li>FIFO 先进先出</li><li>LFU 最不经常使用 需要额外空间记录使用频率</li><li>LRU 最近最少使用 多种实现方式,一般使用双向链表 最新使用的放入链表头,或者已经存在链表中的提到最前面</li></ul><p>机器指令:<br> 形式: 操作码(进行哪种操作)+地址码(给出操作数或者操作数的地址,可能出现 1 个地址,2 个地址,三个地址)<br> 三地址指令: 操作指令 OP 地址 1 地址 2 地址三 比如 1 + 2 结果放到 3 中<br> 二地址指令: 两个操作数结果放到某个地址中<br> 一地址指令: 自己对自己操作<br> 零地址指令: 空操作 停机操作 中断返回操作</p><p>操作类型:<br> 数据传输 算数逻辑操作 移位操作 控制指令<br> 机器指令的寻址方式:<br> 顺序寻址: CPU 执行的指令是按照程序的生成的指令的顺序执行的<br> 跳跃寻址: JMP 调到某个地方去执行<br> 数据寻址方式:</p><p>指令执行过程:<br> 取指令 -- 分析指令 --执行指令<br> 指令和数据缓存到 CPU 的高速缓存 程序计数器指向第一个要执行的指令地址,取出指令操作码地址码需要取数据的话导数据缓存中/地址总线的主存中取 到指令寄存器 发送到指令译码器 同时指令计数器指向下一条指令的起始地址 译码器翻译发送控制信号给运算器 数据装载到寄存器 ALU 计算数据, 状态寄存器记录运算状态,如果进位,或者溢出记录, 送出运算结果<br><a href="https://www.bilibili.com/video/BV1zW411n79C?p=10" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1zW411n79C?p=10</a><br><a href="https://www.bilibili.com/video/BV1rV411k7Xf?p=17" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1rV411k7Xf?p=17</a><br> 控制器和运算器并没有同时工作,效率低<br> 有了 CPU 流水线设计: 分析执行同时取指令分析</p><h1 id="汇编语言" tabindex="-1"><a class="header-anchor" href="#汇编语言"><span>汇编语言</span></a></h1><p>编程语言是汇编语言 ; 汇编语言可以翻译成可直接执行的机器语言; 完成翻译的过程的程序就是汇编器<br> 汇编指令是及其指令便于记忆的书写方式<br> 汇编指令和机器指令是一对一的关系 所有可以通过汇编进行反编译</p><p>汇编指令：<br> MOV AX BX 寄存器 BX 内容送到 AX 寄存器（CPU 里面可以存储数据的器件，比二级缓存低）中</p><p>汇编语言的组成：</p><ul><li>汇编指令</li><li>伪指令（由编译器执行）</li><li>其他符号（编译器识别 + - * / 等）</li></ul><p>存储器 CPU 是计算机的核心，但是想让 CPU 工作，必须向他提供指令和数据（存放在存储器中--内存/显存/网卡存储/BIOS 存...设备都是有内存的）<br> 指令和数据都是二进制信息，把一个二进制数据可以看成是数据，也可以是指令<br> 比如： 1000100111011000 数据： 89D8H 指令：MOV AX，BX<br> 我们指定这个二进制信息是什么就是什么</p><p>CPU 进行数据读写时，必须和外部芯片（各种内存）进行 3 类信息交换： 1.地址信息 即地址总线 寻找数据在存储设备的位置 2.控制信息 即控制总线 对外部设备的控制 控制总线是用来发出各种控制信号的传输线, 控制信号经由控制总线从一个组件发给另外一个组件(CPU 发给内存等),控制总线可以监视不同组件之间的状态（就绪/未就绪） 3.数据信息 即数据总线 把数据传递到 CPU 中 一个整型数据占用 4 字节<br> CPU 发出读写某块地址的地址信息给地址总线，给控制总线发送是读操作还是写操作，和控制哪块设备，然后数据就从数据总线传递到 CPU 里面某块地址上/CPU 把数据写入到那块地址上</p><p>也就是说地址总线里面的二进制数据表示地址，数据总线里面的表示数据，控制总线里面的表示控制的语句</p><p>BIOS 是主板和各类接口卡（显卡网卡等）厂商提供的软件系统，存储在 ROM 中 接口卡也有 BIOS RAM ROM</p><p>内存地址空间： CPU 将各类存储器看作一个逻辑存储器，所有的设备接口卡内存组成一个大的内存空间</p><h1 id="寄存器-cpu-互作原理" tabindex="-1"><a class="header-anchor" href="#寄存器-cpu-互作原理"><span>寄存器（CPU 互作原理）</span></a></h1><p>CPU 内部： 运算器 控制器 寄存器 使用内部总线连接 CPU 连接外部器件是外部总线(三大类的那个)<br> 寄存器 &gt; 缓存 》 二级缓存 》<br> CPU 要取数据，处 bai 理数据，都要放到 du 寄存器处 zhi 理。一般寄存器不用太 dao 大，它只要存放 zhuan 指令一次操作的 shu 数据就够了。<br> 高速缓存是内存的部分拷贝，因为高速缓存速度快，把常用的数据放这里可以提高速度。<br> 高速缓存一般不能被程序直接更改，它由硬件自己处理。程序直接读写 CPU 的寄存器，来完成操作。<br> 一般两者都集成在 CPU 上。</p><p>寄存器是 CPU 内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果 把 111 放在 AX 222 放在 BX 运算器命令 ax + bx 放在 CX 中</p><p>8086CPU 14 个寄存器 都是 16 位 存放两个字节 就是一个字 其中 8 个通用寄存器<br> 通用寄存器 AX BX CX DX 这四个寄存器为了兼容之前的*位寄存器,可以拆开独立使用 AH AL<br> 8086CPU 把地址线 控制线 数据线都从 8 位升成 16 位 所以一次可以读取两个字节 就是一个字存放在寄存器中</p><p>几条汇编指令:<br> 不分大小写 ;<br> MOV ax,18 把 18 放入 ax 寄存器 高级语言表示: AX = 18<br> ADD ax,8 ax 寄存器数值+8 AX = AX + 8<br> MOV ax,bx 把 bx 数据送入 ax 中<br> ADD ax,bx 把 ax + bx 放入 ax</p><p>CPU 访问内存单元时要给出内存单元的地址,所有的内存单元构成的存储单元空间是一个一维的线性空间<br> 16 位 CPU 具有以下性质:<br> 运算器 ALU 一次最多处理 16 位数据 寄存器最大宽度 16 位 寄存器和运算器之间的通路是 16 位<br> 8086CPU 的地址总线是 20 位,能够遍历的地址是 2 的 20 次方 但是内部是 16 位的,只能遍历 16 位的地址,那么多出来的地址怎么表示呢?<br> 内部使用两个 16 位表示表示 20 位物理地址 段地址+偏移地址的方式<br> 段地址 偏移地址 传送到地址加法器 生成 20 位物理地址= 段地址*16 + 偏移地址 也就是段地址左移 1 位<br> 内存被划分成一个一个段?? 没有,只是 CPU 的不足人为加入段<br> CPU 可以用不同的段地址 + 偏移地址找到同一个物理地址<br> 数据在 21F60H 地址中 == 数据在内存 2000:1F60 单元中 == 数据在内存 2000 段 1F60 中<br> 段地址存放在段寄存器 CS 代码段寄存器 DS 数据段寄存器 SS 堆栈 stack 段寄存器 ES 额外的段地址<br> IP 偏移地址寄存器<br> CS + ip 指定 CPU 当前要读取的指令的地址<br> 不能直接把数据 1000H 放入段寄存器,只能把通用寄存器传递到段寄存器</p><h2 id="_8086cpu-执行指令" tabindex="-1"><a class="header-anchor" href="#_8086cpu-执行指令"><span>8086CPU 执行指令:</span></a></h2><p>CS+ip 寄存器里面的地址数据传入到 地址加法器 得到真实的物理地址, 通过控制器 送上地址总线,取得指令(操作码+地址码) 送入数据总线传入指令寄存器 译码器 计算</p><p>8086CPU 加电或者复位时候,CS 设置 FFFF IP 设置 0000, CPU 从内存 FFFF0H 单元读取指令执行第一条指令<br> 程序员只能通过改变 CS IP 寄存器的内容实现对 CPU 的控制!!<br> 使用 mov 关键词不能改变这两个寄存器 而是通过 JMP 加以区分 (JMP 段地址:偏移地址)<br> 仅修改 IP 寄存器 JMP ax 类似 mov ip ax<br> 在编程时候,可以将长度为 N (N&lt;=64KB) 的一组代码存放在连续的起始地址为 16 的倍数的内存单元中(这样可以通过一个段地址+ 偏移地址找到), 从而定义了一个代码段<br> 比如: MOV ax 0000 机器指令(B8 00 00)<br> ad ax 0123 (05 23 01)<br> mv bx ax (8b d8)<br> jmp bx (ff e3) 占用 10 个字节 存放在某一块连续的地址中,这就是代码段<br> 怎么执行这个代码段呢?? 是不是把 CS+ip 指向首地指就可以了 对的<br> CPU 只认被 CS+ ip 指向的内存单元中的内容当做指令来执行 如果是 DS 指向的 CPU 当做是数据而不当做指令去执行</p><h1 id="寄存器-内存访问" tabindex="-1"><a class="header-anchor" href="#寄存器-内存访问"><span>寄存器(内存访问)</span></a></h1><p>任何两个连续的内存单元,N 单元和 N+1 单元,可以看成一个地址为 N 的字单元中的高低位<br> CPU 要读取内存单元的时候,必须知道内存单元的地址,由段地址和偏移地址组成<br> DS 寄存器存放要读取数据的段地址 [address]表示偏移地址为 address 的内存单元(一个字节)<br> MOV al [0] 把内存单元的偏移地址的内容放入寄存器 那么段地址哪里来的呢? 就是 DS 里面的数据 只能把通用寄存器的数据 mov 进去 DS 不能直接 MOV 数据进去</p><p>怎么把数据从内存中送入寄存器?? mov Ax 1000H<br> 怎么把数据从寄存器送入内存单元?? mov bx 1000H mov ds bx; mov [0] ax(把 ax 寄存器的 16 位数据送入 1000:0 处高位 1000:1 低位 1000:0);<br> 因为 8086CPU 是 16 位的数据总线,一次性可传输 16 位数据,一个字<br> mov bx 1000H ; mov ds bx; mov ax [0] 把 1000:0 处的字型数据送入 ax 两个字节的数据哦 因为 ax 是 16 位的 取得数据也就是 16 位的<br> add bx [1] ; 也是把 1001 和 1002 地址的 16 位数据与 bx 相加给 bx<br> 命令后面的寄存器是 16 位的 那么偏移地址也看成 16 位</p><h2 id="mov-add-sub" tabindex="-1"><a class="header-anchor" href="#mov-add-sub"><span>mov add sub</span></a></h2><p>mov 寄存器,数据/寄存器/内存单元(偏移地址[0]) /段寄存器<br> mov 内存单元/段寄存器,寄存器<br> add sub 和 mov 一样 除了不能 add 段寄存器 寄存器<br> 怎么使用数据段?? 将数据段段地址放入到段寄存器, 使用偏移地址[0/1/2/3] 访问具体的数据</p><h2 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h2><p>LIFO last in first out<br> 所有的 CPU 都提供栈的设计,CPU 提供相关的指令来以栈的方式访问内存空间<br> PUSh 入栈 pop 出栈<br> PUSh AX 把 ax 寄存器的数据放入栈中 POP ax 把栈顶的数据放入 AX 寄存器 所以操作的都是字 不是字节<br> 我们把某块连续的地址当做栈来使用 10000H - 1000FH 当作栈, 或者说以栈的方式访问内存空间<br> 执行 MOV ax 0123H<br> push ax<br> mov bx 2266H<br> push bx<br> mov cx 1122H<br> push cs<br> pop ax<br> pop bx; pop cx<br> 字型数据两个字节存放的<br> 那么 CPU 怎么知道哪一块空间被当成栈使用?? push pop 时候怎么知道栈顶单元??<br> SS 段寄存器 存放栈顶的段地址 SP 寄存器 存放栈顶的偏移地址 那么一开始时候 SP 的地址是多少?? 就是栈空间的最高地址的下一个单元 任意时刻 SS:SP 指向栈顶的元素,栈为空时候,就不存在栈顶元素,偏移地址为栈最底部的字单元的偏移地址+2<br> 如上面的地址 SS= 1000H SP=栈长度的后一个单元<br> PUSh AX 的时候 CPU 执行操作: SP=SP-2 将 AX 的内容存放到 SS:SP 地址单元</p><p>那么 CPU 怎么知道栈长度,而不会出现栈顶溢出呢??<br> 栈顶超界是危险的,程序就访问了不属于他的内存的数据,黑客就利用这种方式溢出攻击<br> 如果能够提供寄存器记录栈顶栈低地址就好了 8086CPU 没有解决这种问题<br> 入栈.出栈都要防止越界<br> push/pop 段寄存器/内存单元 可以的<br> 16 位 CPU push 和 pop 的都是 16 位 SP 寄存器 栈顶最大范围: FFFFH</p><p>妙用: 用栈暂存寄存器需要恢复的数据,先将寄存器内容入栈,再出栈到寄存器中 (函数调用就是这样的!!)</p><p>栈段 SS:SP</p><h2 id="汇编编程" tabindex="-1"><a class="header-anchor" href="#汇编编程"><span>汇编编程</span></a></h2><p>GCC 编译器在编译一个 C 语言程序时需要经过以下 4 步：<br> 将 C 语言源程序预处理，生成.i 文件。<br> 预处理后的.i 文件编译成为汇编语言，生成.s 文件。<br> 将汇编语言文件经过汇编，生成目标文件.o 文件。<br> 将各个模块的.o 文件链接起来生成一个可执行程序文件。</p><p>汇编语言:<br> 源代码 编译连接 二进制可执行程序<br> 源代码: 包括伪指令(汇编器执行的)和汇编指令(对应成机器码)<br> assume cs:codeg<br> codeg segment<br> start: mov ax 0123H<br> mov bx 0456H</p><p>codeg ends<br> end</p><p>XXX segment 定义一个段名为 XXX 段 成对使用<br> XXX ends<br> 一个汇编程序是多个段组成,这些段被用来存放代码/数据/栈空间,至少有一个段:代码段<br> end 汇编程序的结束标志,编译器退出<br> assume 假设假如 上面假设代码段是 codeg 段<br> 源程序: 源程序文件中所有的内容<br> 程序: 源程序中最终由计算机执行处理的指令或数据,可执行文件</p><p>计算 2 的 3 次方<br> assume cs:abc<br> abc segement<br> start :move ax,2<br> add ax,ax<br> add ax,ax<br> add ax,ax<br> abc ends<br> end start</p><p>程序 P1 返回: 就是把 CPU 的控制权交还给调用这个程序 P1 的程序<br> mov ax,4c00H int 21H (中断来实现各种 dos 功能的调用) 但是 linux 中都是通过内核来实现的,因此所有的功能都需要系统调用来实现 int 8oh</p><p>汇编器: win 平台 masm linux 平台 nasm<br> nasm -f elf aa.asm win: masm aa.asm 编译生成 obj 文件(将源程序转换机器码,伪指令和汇编指令转成机器码)<br> windows 链接 link aa.obj &gt;&gt;aa.exe 链接:多个目标文件链接到一起,生成一个可执行程序;或者需要调用库程序的某个子程序,需要将库文件和程序的目标文件链接到一起<br> 执行二进制程序后 秒弹黑窗口 又回到 dos<br> 程序没有任何输出,因为只是做了寄存器加法的操作,没向显存写入任何东西</p><h1 id="bx-和-loop-循环" tabindex="-1"><a class="header-anchor" href="#bx-和-loop-循环"><span>BX 和 loop(循环)</span></a></h1><p>[bx] 是什么?? [0]表示一个内存单元时,0 表示偏移地址,段地址在 ds 中,单元的长度可以有具体指令操作的对象指出<br> [bx] 也表示一个内存单元,他的偏移地址在 bx 寄存器中 bx 存的是内存单元的偏移地址<br> mov ax [0] 使用编译器的时候 有可能变成 mov ax 0<br> 所以有了 mov bx 0 , mov ax [bx]</p><p>inc bx bx 自增 1</p><p>为了描述方便<br> 描述性符号 &quot; () &quot; 表示一个寄存器或者内存单元中的内容<br> 比如 ax 的内容是 0010H ==&gt; (ax) =0010H<br> mov ax,[2] ==&gt; (ax) = ((ds)*16 + 2)<br> idata 表示常量 mov ax [idata]</p><p>cx 寄存器是与 loop 指令紧密相关的, 通常我们用 loop 指令来实现循环功能,cx 中存放循环的次数<br> 循环的结构:<br> mov cx 10 s: add ax ax loop s 这样 s 标记的指令段 就循环了 10 次</p><p>段前缀 mov ax ds:[0] 段地址在 ds 中<br> 也可以使用 mov ax cs:[0] 取 cs 中的内容为段地址 mov es:[0] ds</p><p>一段安全的空间: 不能动用核心内存空间哦 被占用的<br> 在存在操作系统的情况下,用汇编语言去操作真实的硬件是不可能的,硬件已经被操作系统利用 CPU 保护模式所提供的功能严格管理起来了<br> dos 下面的安全空间: 0:200H ~ 0:2ffH</p><h1 id="包含多个段的程序" tabindex="-1"><a class="header-anchor" href="#包含多个段的程序"><span>包含多个段的程序</span></a></h1><p>目前我们只在安全空间下面编程,如果内存不够用怎么办?? 找操作系统分配<br> 先来看 dw define word 定义字型数据 db 定义字节型数据<br> 在代码段中使用数据<br> dw 1234H,1245H,1256H dw 写在 segment 里面,的开头 里面的数据占用的内存空间 段地址就是 segment 是哪个 cs? ds? 就是哪个<br> 偏移地址就是 0 2 4 6</p><p>start 伪指令放在 dw 下面就好了 指向真正的要执行的机器指令 而不是让 CPU 从 dw 的数据开始执行<br> 在代码段中使用栈<br> dw 声明几个字的内存空间,然后把栈段 ss 指向代码段的段地址,sp 指向空间的最高地址+1 这样声明的那块内存空间就可以被我们当成栈使用</p><p>怎么将数据 代码 栈 放入不同的段<br> 使用 assume 声明多个段<br> assume ds:data,cs:code,ss:stack<br> data segment<br> dw <strong>,</strong>,<strong>,</strong><br> data ends</p><p>start: mov ax,data<br> mov ds,ax</p><p>and 指令(逻辑与指令) or 指令<br> 改变字母的大小写就是改变 AScll 码值<br> idata 就是数字<br> 偏移地址可以用 [bx + idata]表示 ，比如 bx+1 或者 1[bx]<br> DI 和 SI 是对 BX 寄存器的补充，但是不能拆分成 8 位寄存器<br> 比如复制的操作，就用 DS:SI 表示原始的内存空间，用 DS:DI 表示目标地址空间<br> [bx + si + 1] 表示一个内存的偏移地址</p><p>双层循环怎么做？？ loop 默认跟 cx 绑定 在第一层循环中，把 cx 的值暂存到寄存器中，但是寄存器是有限的，如果程序比较大，就寄存器都在二层循环中用了，只有存到内存中！！ 才是合理的<br> 8086CPU 中只有四个寄存器可以用在偏 x 移地址中[]，bx si di bp 进行内存单元的寻址 只能 bx + si/di , bp + si/di<br> bp 对应的段地址是 ss 是支援 sp 用的</p><p>CPU 处理的数据可以在三个地方： CPU 内部（寄存器） 内存（偏移地址） 端口<br> CPU 找数据的方式就是寻址方式 直接寻址（就是直接的数值 mov ax,1） 寄存器寻址（mov ax,bx 数据存放在 bx 寄存器中） 寄存器相对寻址（mov ax,[bx+idata]） 基址变址寻址（mov ax,[bx+si]） 相对基址变址寻址（mov ax,[bx+si+idata]）</p><p>div 指令： division（除法）<br> dd （double word） 32 位</p><h1 id="转移指令" tabindex="-1"><a class="header-anchor" href="#转移指令"><span>转移指令</span></a></h1><p>offset 在汇编语言中，由编译器处理的符号，是： 取得标号的偏移地址<br> start: mov ax, offset start ==&gt; mov ax,0<br> s:mov ax,offset s =&gt; mov ax,3<br> jmp 是无条件跳转指令,可以只修改 IP 也可以同时修改 CS 和 IP<br> call 和 ret 指令都是转移指令,可以修改 IP 或者 CS 和 IP<br> ret 使用栈中的数据,修改 IP 的内容,实现近转移 相当于 pop IP 栈数据放到 IP 寄存器中<br> retf 使用栈中的数据,修改 CS + IP 的内容 实现远转移 相当于 pop IP pop cs<br> call 指令 call 标号 把当前 IP 或者 cs+ip 入栈 然后跳转 JMP 到标号的地方去执行<br> 就是函数调用啦!! easy<br> mul 指令： 乘法</p><h1 id="标志寄存器" tabindex="-1"><a class="header-anchor" href="#标志寄存器"><span>标志寄存器</span></a></h1><p>8086 标志寄存器都是 16 位的，存储的信息被称为程序状态字 （PSW）<br> ZF 标志 上一条指令操作结果为 0 那么 0 标志位就是 1<br> SF 标志 记录指令执行成功后结果的正负数<br> CF 标志 进位标志位 当数据相加益处的时候，用 CF 标志进位了<br> DF 标志 方向标志位</p><h1 id="内中断" tabindex="-1"><a class="header-anchor" href="#内中断"><span>内中断</span></a></h1><p>CPU 去处理事件，处理完成，继续 CPU 原来的操作<br> 外部中断： 键盘 打印机 定时器 等 是可以屏蔽的中断，利用中断控制器是可以屏蔽的<br> 内部中断： 是指因硬件错误或者运算错误，不可屏蔽的</p><p>中断向量表 就是去找中断处理程序的中间产物，在内存中存储，存放 256 个中断源所对应的中断处理程序的入口，所以这块内存是很重要的</p><p>知道了处理中断程序的地址，我们就可以重新写中断处理程序，把程序的入口放到中断向量表中</p><p>单步中断<br> CPU 在执行了一条指令后，就去作其他的事情了，就会有单步中断的效果。<br> CPU 在执行了一条指令后，如果检测到标记寄存器的 TF 位为 1 则产生单步中断 引发中断过程， 单步中断的中断类型码为 1</p><h1 id="int-指令" tabindex="-1"><a class="header-anchor" href="#int-指令"><span>int 指令</span></a></h1><p>int n (n 为中断类型码) 他的功能是引发中断程序<br> 一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用<br> BIOS CPU 加电后从 cs=0ffffH ip=0 内存开始执行 ffff:0 有一条调转指令，转去执行 bios 硬件系统检测和初始化程序（建立 BIOS 提供的中断历程的入口地址登记在中断向量中）完成后调用 int 19 进行操作系统引导</p><h1 id="端口" tabindex="-1"><a class="header-anchor" href="#端口"><span>端口</span></a></h1><p>CPU 可以直接读取三个地方的数据：<br> CPU 内部的寄存器<br> 内存单元<br> 端口</p><h2 id="对端口的读写" tabindex="-1"><a class="header-anchor" href="#对端口的读写"><span>对端口的读写</span></a></h2><p>in out 指令<br> in al,60H 从 60H 号端口读入一个字节</p><p>CMOS RAM 芯片<br> 包含一个实时钟和一个 128 个存储单元的 RAM<br> 该芯片依靠电池功供电，保存 BIOS 的配置信息<br> 芯片内部有两个端口，70H 和 71H，CPU 通过这两个端口读写 CMOS RAM</p><p>CPU 除了具有运算的能力还有 I/O 能力<br> 外设的输入不直接送入内存中，而是送入相关的接口芯片的端口中<br> CPU 向外设的输出也不是直接送入到外设，而是先送入到端口中，在有相关的芯片送到外设</p></div><!----><!----><!----></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/Hero-King/asset/edit/main/docs/system/AssemblyLanguageNote.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">最近更新</span><time class="vp-meta-info" datetime="2025-11-22T10:49:26.000Z" data-allow-mismatch>2025/11/22 10:49</time></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 838774057@qq.com">HeroKingMini</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/system/os.html" aria-label="操作系统介绍"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->操作系统介绍</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2025 HeroKing </div></footer></div><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-CPWYzFNH.js" defer></script>
  </body>
</html>
