### 操作系统介绍
系统软件！！
https://www.bilibili.com/video/BV1js411b7vg?from=search&seid=2313098069245169080 B站清华大学公开课
https://github.com/chyyuu/os_course_info 资料

ucore操作系统练习 github.com/chyyuu/mooc_os_lab

操作系统对资源进行了抽象： 
- CPU 抽象成进程 
- 磁盘 抽象成文件
- 内存 抽象成地址空间

层次结构： 硬件之上，应用程序之下
课程关注的是 kernel （内核） 不是shell

内核的特征： 并发；共享资源（多个应用访问同一个资源）；虚拟（多道程序设计技术，让用户觉得自己独占一台计算机）； 异步（程序的执行并不是一贯到底，而是走走婷婷，向前推进的速度不可预知）

补充：  并发和并行的区别
并发（在一段时间内可以有多个程序运行； 而并行是在一个时间点上同时执行多个程序：要求计算机有多个CPU）
并发是指一个处理器同时处理多个任务。 指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。
并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。
当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。
当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。
来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。

主要操作系统
unix BSD 系统 ，linux 家族 , windows家族...
历史发展： 起步 -》多道程序设计（异步） -》分时操作系统（时间片轮转 底层使用时钟）-》多核多处理 -》 分布式系统（网路的提高，PC性能提高，出现数据中心的概念）  

内核的设计思路： 
内核： 函数调用
微内核： 尽可能的小，可移植的方式存在，只保留基本的功能比如消息传递，中断处理，（之前的设计都是耦合大，通过函数调用的方式，未模块化）
把 内存管理，网络管理，IO ,设备驱动 放在外围，以服务的形式存在，服务与服务之间通讯通过内核的消息传递机制，松耦合，代价是性能（数据 -》内核 -》服务） 
外核： 内核分成两个部分，内核面向硬件，外核是应用自己定制的lib core -》内核-》硬件
VMM（虚拟机监视器）在操作系统和硬件之间多了一层

### 系统启动 中断/异常/系统调用
启动：  CPU / 内存 / IO 通过总线连接
接电之后 执行内存中特定地址的BIOS程序（自检显卡，外设正常和执行BIOS（加载硬盘中bootloader（第一个启动扇区））） 加载内核

外设 通过 中断和io处理
应用程序 通过 系统调用和异常处理
            来源
中断      外设     
异常    应用程序意想不到的行为 
系统调用    应用程序请求操作系统提供服务

中断：  
硬件操作：设置中断标记（CPU初始化）/ 中断事件ID  CPU会根据中断表寻找对应ID的中断处理程序执行
软件操作： 保存当前处理状态；中断服务程序处理；清除中断标记；恢复之前保存的处理状态
异常：
保存现场；异常处理（杀死/重启等）；恢复现场 
系统调用：
应用程序发出调用；操作系统去处理
API ：   win32 API 用于windows     POSIX API 用于linux unix macos  java api 用于jvm (jvm在调用win32 或者posix)
 
操作系统用户态： cpu不能执行一些特殊的指令 特权指令 io处理
操作系统内核态： cpu可以执行任何指令
用户程序调用操作系统系统调用的时候，将从用户态转为内核态，控制权从应用程序交给操作系统，完成堆栈的转换【内核堆栈和应用程序堆栈】（如果是函数调用（应用程序直接调用内核的函数）的化就只有一个堆栈）
#### 系统调用和函数调用的区别
操作系统有自己的堆栈， 执行时间上慢于函数调用
系统调用需要建立中断/异常/调用号和对应服务历程的影射关系
系统调用会验证 参数
内核态到用户态的转换

### 操作系统体系结构/内存分层
操作系统把内存抽象成 逻辑地址空间（使得编程看到的内存是连续的空间）保护独立地址空间（硬盘 内存条的地址）
内核占用的内存  程序1占用的内存  程序2内存  ...            不够了的话使用虚拟内存
内存里面存放什么？？   代码区 堆栈数据区 共享程序段 等
我们自己写的代码处理的是逻辑地址，编译（将基于符号的地址空间转换成逻辑地址空间），汇编，链接，都是逻辑地址  CPU 通过ALU查询MMU地址影射关系表找到真实地址 提取指令执行。 操作系统要做的是做好地址影射表

连续内存空间分配  ->算法
- 第一匹配  寻找到第一块空闲空间》需要的空间大小的时候，就分配给他 优点：简单，方便产生结尾的大空间块 缺点：随着时间推移，容易产生外碎片，不同程序之间的地址块越来越小
- 最优匹配 寻找最适合的一块空间 找到与需要的空间大小最接近的内存块
- 最差匹配 与最优相反 

内存整理： 
压缩式碎片整理： 把分离开的内存片段 移动到一起，就把碎片空间整理出来了，但是移动的时机？？ 开销也比较大
交换式碎片整理： CPU处理的的程序需要更多的内存时候，但是没有空闲的物理内存，这时候把停止的等待IO，中断的程序所占用的内存放到硬盘上 腾出空间（当程序大的时候耗费的开销也大）

缺点：
- 分配给一个程序的物理内存是连续的
- 内存利用率比较低
- 有外碎片/内碎片的问题


非连续内存分配
优点： 
- 更好的内存利用和管理
- 允许共享代码和数据（共享库等等）
- 支持动态加载和动态链接
缺点： 
如何建立虚拟地址和物理地址的转换 ？ 
分段和分页 物理硬件支持
分段： 把逻辑地址空间分段，比如程序段，程序数据段，运行栈， 运行堆 分配到不同的物理地址上，就是内存块
这样的话 逻辑地址怎么映射到物理地址中？？  段地址（段号）+段内偏移 （段寄存器寻址+地址寄存器寻址）
段表： 存放段号和物理地址的影射关系，段号长度的限制   由操作系统设置

分页  也是建立计算关系 页码+ 偏移
页表：                 操作系统建立
性能存在问题： 页表可能非常大/访问内存单元需要两次计算
解决： 缓存  cpu中快表TLB缓存近期访问的
        多级页表  节约空间

### 虚拟内存
基于分段或者分页硬件支持的技术 + 操作系统有效的管理  实现以更小的力度为单位采用自动的虚拟存储技术
早前技术： 
覆盖技术： 分时间实现小内存运行大软件，不运行的代码，后调用的代码存放在硬盘，运行后的代码被后来的硬盘中取出的代码覆盖   对程序元要求较高，书写的代码需要分块调用（一个程序之内）
交换技术： 多道程序在跑的时候，暂时不运行的程序送到硬盘中；
操作系统把一个进程的整个地址空间保存到硬盘上，将硬盘某个进程的地址空间读入内存中（多个程序之间，操作系统完成）

虚拟内存技术： 程序局部性原理 + 分段分页机制 + 不连续内存管理
计算机利用局部性原理读入某段或某页数据 程序的其它内容在硬盘上； CPU丢失数据指令了 发出异常，操作系统处理判断内存空间是否够用？ 并读入新的数据 ： CPU 判断不使用的数据村入硬盘，腾出新的内存在读入缺失的数据
