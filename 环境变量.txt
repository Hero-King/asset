Linux的变量种类
按变量的生存周期来划分，Linux变量可分为两类： 
1 永久的：需要修改配置文件，变量永久生效。 
2 临时的：使用export命令声明即可，变量在关闭shell时失效。

设置变量的三种方法
1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】 
用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 
例如：编辑/etc/profile文件，添加CLASSPATH变量 
# vi /etc/profile 
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib

注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。

2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】 
用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 
例如：编辑guok用户目录(/home/guok)下的.bash_profile 
vi/home/guok/.bash.profile添加如下内容：exportCLASSPATH=./JAVAHOME/lib;JAVA_HOME/jre/lib 
注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。

3 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】 
在shell的命令行下直接使用[export 变量名=变量值] 定义变量，

该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，

shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。

环境变量的查看
1 使用echo命令查看单个环境变量。例如： 
echo $PATH 
2 使用env查看所有环境变量。例如： 
env 
3 使用set查看所有本地定义的环境变量。

使用unset删除指定的环境变量
set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。示例如下： 
export TEST="Test..." #增加一个环境变量TEST env|grep TEST #此命令有输入，证明环境变量TEST已经存在了 
TEST=Test... 
unset  TEST #删除环境变量TEST 
$ env|grep TEST #此命令没有输出，证明环境变量TEST已经删除

常用的环境变量
PATH 决定了shell将到哪些目录中寻找命令或程序 
HOME 当前用户主目录 
HISTSIZE　历史记录数 
LOGNAME 当前用户的登录名 
HOSTNAME　指主机的名称 
SHELL 当前用户Shell类型 
LANGUGE 　语言相关的环境变量，多语言可以修改此环境变量 
MAIL　当前用户的邮件存放目录 
PS1　基本提示符，对于root用户是#，对于普通用户是$


这个年代， 大家写点书， 也无非就是为了搞点钱， 基本都是罗列一些知识点， 基本都是写给已经会了的人看的。 
真正用心写书的人， 不多。 如果真正用心写书， 且站在读者的角度去写， 那就少之又少了。
    关于linux shell环境变量， 我看了四本linux相关书的介绍，结果，没有一本书的讲解让我完全满意， 总感觉没有说清楚。
所以呢， 我打算自己来写一下，如有不当指出， 请大家指正。
        一. 永久环境变量（实际上属于文件， 而不属于shell, 每打开一个shell, 都会加载/导入到shell中， 形成当前shell的临时环境变量）

        先说说"永久环境变量"， 其实， 我也知道， 没有什么东西是真正永久的， 这里的永久是指： 变量存储在文件中， 不会因为掉电或者关机而消失。下面， 我们打开一个linux shell, 并打印HOME的值， 如下：

[taoge@localhost Desktop]$ echo $HOME
/home/taoge 
       我们看到HOME这个变量的值是/home/taoge, 这个变量的值是从哪里来的呢？ 我们可以看看用户主目录下的.bashrc文件

[taoge@localhost Desktop]$ cat ~/.bashrc 
      其中的内容为：

# .bashrc
 
# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
 
# User specific aliases and functions
       啊？ 居然没有HOME? 不要着急， 先姑且认为是在/etc/bashrc中进行了HOME的设置吧， 在此， 我们不深究， 只需要有这个认识： HOME与文件~/.bashrc密切相关， 即使断电或者掉电， 也不怕消失。



      实际上， 当我们开启一个shell进程的时候， HOME这个永久环境变量会自动导入到当前的shell中来（为当前shell设置了一个临时的环境变量）， 那这个HOME可不可以被unset掉呢？ 我们来看一下：

[taoge@localhost Desktop]$ echo $HOME
/home/taoge
[taoge@localhost Desktop]$ unset HOME
[taoge@localhost Desktop]$ echo $HOME
 
[taoge@localhost Desktop]$ 
      我们看到， 当前shell进程中的HOME确实是被unset掉了， 不要着急， 我们另外打开一个shell进程， 然后看看有没有HOME,  如下：

[taoge@localhost Desktop]$ echo $HOME
/home/taoge
[taoge@localhost Desktop]$
      可以看到， 第二个shell进程中是有HOME的， 这个不难理解， 因为开启第二个shell进程的时候， 会把~/.bashrc中的永久HOME加载一次， 所以可以看到/home/taoge.


      我们暂时来总结一下： 永久环境变量存在于~/.bashrc文件中（掉电或者重启后， 不会消失）， 在每个shell启动的时候， 都会将永久环境变量导入到shell中， 并成为shell的临时环境变量， 这个临时的环境变量可以被unset掉后， 但不会影响其他shell， 因为我们即将会说到， 不同shell的临时环境变量是彼此独立的。



      你可能还在纠结并不耐烦地发出疑问：在~/.bashrc中没有看到HOME啊， 你不是在扯淡么？ 好， 我们自己来把一个变量写入到~/.bashrc文件中， 使之成为永久环境变量， ~/.bashrc文件内容如下：

# .bashrc
 
# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
 
# User specific aliases and functions
 
 
# define permanent variable by taoge
winner="people who persists"
      我定义winner这个变量的值为“people who persists”, 好， 保存文件， 我们来查看一下winner这个变量， 如下：
[taoge@localhost Desktop]$ echo $winner
 
[taoge@localhost Desktop]$  
      遗憾的是， 我们没有看到winner, 为什么呢？ 因为现在只是把winner变成了永久环境变量， 这个永久环境变量并没有加载到当前的shell中来啊！ 好吧， 我们关掉当前的shell, 并打开一个新的shell,  再查看一次， 如下：

[taoge@localhost Desktop]$ echo $winner
people who persists
[taoge@localhost Desktop]$ 
      可以看到， 这次winner有值了， 激动吧。 这样， 无论以后是重启linux, 还是怎么滴， winner就成为了文件的一部分， 就成了永久的环境变量了。 当然， 你要是把~/.bashrc文件中的winner那一行删除了， 然后跟我说：你不是说永久的么？ 现在怎么不永久啦？  好吧， 你这是在故意找茬。



      二. 临时的环境变量（属于当前shell及其子进程）

       上面我们已经说了， winner成了永久的环境变量， 当一个shell开启的时候， 便会加载这个winner变量， 那么在当前shell环境中， 这个winner就会变成临时的环境变量。 之所以说是临时的， 是因为你可以把他unset掉， 之所以说是环境变量， 意思是说（没被unset掉的时候）， 当前shell进程的子进程可以访问到该winner, 如下：

[taoge@localhost Desktop]$ echo $$
7203
[taoge@localhost Desktop]$ echo $winner
people who persists
[taoge@localhost Desktop]$ bash
[taoge@localhost Desktop]$ echo $$
7354
[taoge@localhost Desktop]$ echo $winner
people who persists
[taoge@localhost Desktop]$ exit
exit
[taoge@localhost Desktop]$ echo $$
7203
[taoge@localhost Desktop]$ 
      我们看到， 当前进程pid是7203， 为它再开一个子shell进程， 子进程的pid为7354， 我们可以看到， 在进程中， 也可以访问到winner.   



      上面的winner是~/.bashrc中永久环境变量加载而来的， 那我们可不可以自定义临时环境变量呢？ 可以的。 这次， 我们运行a.sh脚本来做当前shell的子进程， 如下：

[taoge@localhost Desktop]$ export x="defined in shell"
[taoge@localhost Desktop]$ vim a.sh
[taoge@localhost Desktop]$ cat a.sh 
#! /bin/bash
echo $x
[taoge@localhost Desktop]$ chmod +x a.sh 
[taoge@localhost Desktop]$ ./a.sh 
defined in shell
[taoge@localhost Desktop]$ 
     可以看到， 在脚本子进程中， 也可以访问x这个临时的环境变量。 好， 我问个问题， 那别的shell能访问这个x么？  我们再开启另外一个shell, 如下：
[taoge@localhost Desktop]$ echo $x
 
[taoge@localhost Desktop]$  
     肯定是没有啊， 上面的一些例子都揭露了临时环境变量的本质： 当前shell的临时环境变量， 能被自己及其子进程(子shell进程, 子脚本进程或者子C程序进程)访问， 但不能被其它shell访问(相互独立)。 对了， 我们上面已经讨论过了， 临时的环境变量可以被unset掉。在实际大型的软件开发中， 编译大工程， 经常需要用到临时环境变量。



      三. 普通变量（属于当前shell进程）

      shell中的普通变量很简单， 仅能被当前shell访问， 不能被其子进程访问， 更不能被其它shell访问。 当然， 它也可以被unset掉， 测试如下：

[taoge@localhost Desktop]$ z="f(y)"
[taoge@localhost Desktop]$ echo $z
f(y)
[taoge@localhost Desktop]$ echo $$
7578
[taoge@localhost Desktop]$ bash
[taoge@localhost Desktop]$ echo $$
7653
[taoge@localhost Desktop]$ echo $z
 
[taoge@localhost Desktop]$ exit
exit
[taoge@localhost Desktop]$ echo $$
7578
[taoge@localhost Desktop]$ unset z
[taoge@localhost Desktop]$ echo $z
 
[taoge@localhost Desktop]$
     可见， 确实不能被子shell访问， 当然， 肯定更不能被其它shell访问了。   普通变量要提升了临时的环境变量， 那也很简单， 加一下export就可以了， 如下：
[taoge@localhost Desktop]$ z="f(y)"
[taoge@localhost Desktop]$ echo $z
f(y)
[taoge@localhost Desktop]$ echo $$
7578
[taoge@localhost Desktop]$ export z
[taoge@localhost Desktop]$ bash
[taoge@localhost Desktop]$ echo $$
7723
[taoge@localhost Desktop]$ echo $z
f(y)
[taoge@localhost Desktop]$ exit
exit
[taoge@localhost Desktop]$ echo $$
7578
[taoge@localhost Desktop]$ 


       啰嗦地总结一下：shell中的普通变量， 仅能被当前shell访问， 不能被其子进程访问， 更不能被其它shell访问。 当然， 它也可以被unset掉。


      OK,  我觉得我应该说清楚了， 早休息！
