### GitHub 提供的主要功能

- Git 仓库
- Issue

```
Issue 功能，是将一个任务或问题分配给一个 Issue 进行追踪和管理
的功能。可以像 BUG 管理系统或 TiDD（Ticket-driven Development）的
Ticket 一样使用。
每一个功能更改或修正都对应一个 Issue，讨论或修正都以这个
Issue 为中心进行。只要查看 Issue，就能知道和这个更改相关的一切信
息，并以此进行管理。
在 Git 的提交信息中写上 Issue 的 ID（例如“#7”），GitHub 就会自
动生成从 Issue 到对应提交的链接。另外，只要按照特定的格式描述提
交信息，还可以关闭 Issue。
```

- Wiki

```
通过 Wiki 功能，任何人都能随时对一篇文章进行更改并保存，因
此可以多人共同完成一篇文章。该功能常用在开发文档或手册的编写
中。同时支持git管理
```

- Pull Request

```
开发者向 GitHub 的仓库推送更改或功能添加后，可以通过 Pull
Request 功能向别人的仓库提出申请，请求对方合并。

```

### 实际操作学习 git

git diff 查看工作树和暂存区的差别
git diff HEAD 查看工作树和最新提交的差别
git branch 显示分支一览表
git log --graph——以图表形式查看分支
git reflog 命令恢复到原先的状态
git commit --amend——修改提交信息

在日常开发中,往往会创建数个特性分支,同时在
此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常
由 master 分支担当

### Issue

开发者们为了跟踪 BUG 及进行软件相关讨论,进而方便管理,创建了 Issue。

- 发现软件的 BUG 并报告
- 有事想向作者询问、探讨
- 事先列出今后准备实施的任务

Issue 可以通过添加标签(Label)来进行整理。

#### 通过提交信息操作 Issue

- 在相关 Issue 中显示提交
  在 Issue 一览表中我们可以看到,每一个 Issue 标题的下面都分配了
  诸如“#24”的编号。只要在提交信息的描述中加入“#24”,就可以如
  图 5.18 所示,在 Issue 中显示该提交的相关信息,使关联的提交一目了
  然。这里只需轻轻点击一下便可以显示相应提交的具体内容,在代码审
  查时省去了从大量提交日志中搜索相应提交的麻烦,非常方便。
- Close Issue
  只要在该提交中以下列任意一种格式描述提交信息,对应的 Issue 就会被 Close。 fix #24 fixes #24 fixed #24 close #24 closed #24 resolve #24 resolved #24 等等

Tasklist 语法 #本月要做的任务

- [ ] 完成图片
- [x] 完成部署工具的设置 --> 复选列表的样式
- [ ] 实现抽签功能

### Pull Request

Pull Request 是自己修改源代码后,请求对方仓库采纳该修改时采取的一种行为。
<img src="img/pull request概念图.png"/>

- Fork 到自己仓库 Pull Request

1. fork 原来的仓库（resource）到自己的 github 中
2. clone 代码,新建特性分支专注解决这个问题
3. 本地修改代码，解决 bug，后提交代码到自己的仓库中
4. 在仓库中发起 pull request 请求，请求 resource 仓库合并我的代码
5. resource 仓库管理员审核代码，测试代码后通过即可合并

向发送过 Pull Request 的分支添加提交时,该提交会自动添加至已
发送的 Pull Request 中。 这一方法要求尽早发送 Pull Request,越早效果越明显。

- 不进行 Fork 直接从分支发送 Pull Request
  如果用户对该仓库有编辑权限,则可以直接创建分支,从分支发送 Pull Request。
  利用这一设计,团队开发时不妨为每一名成员赋予编辑权限,免去 Fork 仓库的麻烦。这样,成员在有需要时就可以创建自己的分支,然后直接向 master 分支等发送 Pull Request。

补充: 版本号
版本号的分配规则
版本控制策略规定了软件版本号的分配规则，因此制定该策
略时应当尽量简单易懂。
比如在用 x.y.z 格式进行版本管理时的规则如下所示。
● …x 在重大功能变更或新版本不向下兼容时加 1，此时 y 与 z
的数字归 0
● y 在添加新功能或者删除已有功能时加 1，此时 z 的数字归 0
● z 只在进行内部修改后加 1
下面举个具体例子。
● 1.0.0：最初发布的版本
● 1.0.1：修正了轻微 BUG
● 1.0.2：修复漏洞
● 1.1.0：添加新功能
● 2.0.0：更新整体 UI 并添加新功能
这便是版本号的大致分配规则。
如果团队采用了 Git…Flow，那么成员在交流的时候会经常用
到版本号，因此版本控制策略越早制定越好。
