@startuml ExpressSimplifiedSequence
actor Developer
participant "app" as Application
participant "app.router" as Router
participant "route" as Route
participant "layer" as Layer


' 应用初始化
Developer -> Application: const app = express()
Application -> Application: app.init() \n app.defaultConfiguration()

' 注册/info路由
Developer -> Application: app.get('/info', h1, h2, h3)
Application -> Router: router.route('/info')
Router -> Router: 初始化(单例模式)
Router -> Route: new Route('/info')
Router -> Layer: new Layer('/info',router.dispatch)
Router -> Router: Layer关联Route\nrouter.stack.push(layer)
Router -> Application: 返回Route
Application -> Route: route.get(h1, h2, h3)
Route -> Layer: new Layer('/', h1)
Route -> Layer: new Layer('/', h2)
Route -> Layer: new Layer('/', h3)
Route -> Route: this.stack.push(layer)
Route -> Application: return

' 注册/info2路由
Developer -> Application: app.get('/info2', h1, h2, h3)
Application -> Router: router.route('/info2')
Router -> Route: new Route('/info2')
Router -> Layer: new Layer('/info2',router.dispatch)
Router -> Router: Layer关联Route\nrouter.stack.push(layer)
Router -> Application: 返回Route
Application -> Route: route.get(h1, h2, h3)
Route -> Layer: new Layer('/', h1)
Route -> Layer: new Layer('/', h2)
Route -> Layer: new Layer('/', h3)
Route -> Route: this.stack.push(layer)
Route -> Application: return


' 启动服务器
Developer -> Application: app.listen(3000, callback)

' 创建请求
Developer -> Application: req.get('/info')
Application -> Application: this.handle(req, res, out)
note left of Application
这里的req,res为原始的请求对象和响应对象
  - req.res = res; res.req = req; 保存关联
  - Object.setPrototypeOf(req, app.request) 
  - Object.setPrototypeOf(res, app.response)
  - 原型方式拓展req,res
end note
Application -> Router: router.handle(req, res, finalhandler)
Router -> Layer: 启动next方法 \n 遍历stack查找匹配的layer和Route \nlayer.match('/info')
Layer -> Router: 返回是否match
Router -> Route: route._handlesMethod('GET')\n判断Route的方法是否匹配
Route -> Router: 返回是否match
Router -> Layer: layer.handleRequest(req, res, next)
Layer -> Route: route.dispatch(req, res, next)
Route -> Layer: 启动next方法 \n 遍历stack根据method查找匹配的layer \nlayer.handleRequest(req, res, next)\n执行传入的h1,h1中继续调用next

Route -> Layer: layer.handleRequest(req, res, next)\n执行传入的h2,h2中继续调用next
Route -> Layer: layer.handleRequest(req, res, next)\n执行传入的h3,h3中继续调用next
note left of Route
一直在压栈next方法,最后在慢慢弹栈
end note

Router -> Layer: Router.next\n查找匹配stack中其他的layer\n重复上述步骤
Router -> Developer: 响应内容

@enduml