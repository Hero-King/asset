import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as r,e as s,r as n,o}from"./app-MIZpsOfp.js";const a={};function p(d,e){const l=n("Mermaid");return o(),t("div",null,[e[0]||(e[0]=r('<h1 id="nestjs" tabindex="-1"><a class="header-anchor" href="#nestjs"><span>Nestjs</span></a></h1><p>查看帮助 <code>nest --help</code></p><p>项目创建</p><ul><li>nest create 项目名称</li><li>pnpm run start:dev 启动开发</li><li>nest g res <code>&lt;name&gt;</code> 生成 res 资源</li></ul><h2 id="重要概念" tabindex="-1"><a class="header-anchor" href="#重要概念"><span>重要概念</span></a></h2><ul><li>控制器@Controller: 路由, 处理传入的请求并向客户端返回响应, 必须属于某一个模块</li><li>提供器@providers: 由 Nestjs 容器管理的 js 类, 框架负责实例化, 管理其生命周期, 作为依赖注入的类</li><li>module@Module: nest 组织应用的方式, 应用至少需要有一个根模块 <ul><li>providers: 将由 Nest 注入器实例化并且至少可以在该模块中共享的提供程序</li><li>controllers: 此模块中定义的必须实例化的控制器集</li><li>imports: 导出此模块所需的提供程序的导入模块列表</li><li>exports: 这个模块提供的 providers 的子集应该在导入这个模块的其他模块中可用。你可以使用提供器本身或仅使用其令牌（provide 值）</li></ul></li></ul><h2 id="工程目录" tabindex="-1"><a class="header-anchor" href="#工程目录"><span>工程目录</span></a></h2><ul><li>src/main.ts 应用程序的入口文件，它使用核心函数 NestFactory 来创建 Nest 应用程序实例。</li><li>src/app.module.ts 应用程序的根模块。</li><li>src/app.controller.ts 一个具有单个路由的基本控制器。</li><li>src/app.service.ts 一个具有单个方法的基本服务。</li></ul><h2 id="模块" tabindex="-1"><a class="header-anchor" href="#模块"><span>模块</span></a></h2><p>下述中的 <code>js类</code> 其实是为框架读取使用, 真正导出导入的是容器中帮我们创建好的实例</p><ul><li>共享模块: 使用 @Module.exports 导出 <code>js类</code>, 其他需要使用的模块中 @Module.import</li><li>全局模块: 在模块上使用@Global()注解, 其他模块直接注入<code>js类</code>即可, 不需要在@Module.import</li><li>动态模块: 编写模块类, 实现 forRoot 静态方法, 返回模块配置对象即可</li></ul><h2 id="中间件-middleware" tabindex="-1"><a class="header-anchor" href="#中间件-middleware"><span>中间件 (Middleware)</span></a></h2><ul><li>职责：最基础的层面。处理请求和响应对象，执行任何代码，对请求和响应进行更改。它可以结束请求-响应周期（比如权限验证失败直接返回 403）。</li><li>使用场景： <ul><li>CORS (跨域资源共享)</li><li>日志记录 (Morgan)</li><li>请求体解析 (BodyParser)</li><li>Cookie / Session 处理</li></ul></li><li>特点：最通用，但职责不明确，什么都能做。</li></ul><h2 id="守卫-guard" tabindex="-1"><a class="header-anchor" href="#守卫-guard"><span>守卫 (Guard)</span></a></h2><ul><li><p>职责：路由守卫。只有一个核心任务——决定一个请求是否应该由路由处理程序处理。它通常实现 CanActivate 接口，返回一个布尔值。</p></li><li><p>使用场景：</p><ul><li>身份认证 (Authentication)：检查请求是否携带有效的 JWT Token。</li><li>授权 (Authorization)：检查认证通过的用户是否有权限访问该接口（例如：角色校验 RolesGuard）。</li></ul></li><li><p>特点：在中间件之后执行，且可以访问 ExecutionContext（执行上下文），拥有更多的关于当前处理程序的信息。</p></li></ul><h2 id="拦截器-interceptor" tabindex="-1"><a class="header-anchor" href="#拦截器-interceptor"><span>拦截器 (Interceptor)</span></a></h2><ul><li><p>职责：在方法执行前后添加额外的逻辑。它可以在函数执行前、后拦截，甚至可以完全覆盖或延迟函数的执行（例如缓存）。它实现了 AOP（面向切面编程） 的思想。</p></li><li><p>使用场景：</p><ul><li>额外逻辑绑定：如缓存拦截、日志记录。</li><li>转换响应：将处理程序返回的数据包装成统一的格式（{ code: 200, data: {}, message: &#39;success&#39; }）。</li><li>转换异常：将方法抛出的异常转换为另一种异常。</li><li>扩展函数行为：例如超时处理。</li></ul></li><li><p>特点：功能非常强大，是 NestJS 的亮点之一。它可以修改函数返回的结果。</p></li></ul><h2 id="管道-pipe" tabindex="-1"><a class="header-anchor" href="#管道-pipe"><span>管道 (Pipe)</span></a></h2><ul><li><p>职责：数据转换和验证。将输入数据转换为所需的格式（如字符串转为整数），并验证输入数据，如果数据不合格则抛出异常。</p></li><li><p>使用场景：</p><ul><li><p>验证：使用 class-validator 库验证 DTO（数据传输对象），无效时自动抛出 BadRequestException。</p></li><li><p>转换：将路径参数 :id 从字符串转换为数字 (ParseIntPipe)。</p></li></ul></li><li><p>特点：通常用于控制器路由处理程序的参数级别。</p></li></ul><h2 id="异常过滤器-exception-filter" tabindex="-1"><a class="header-anchor" href="#异常过滤器-exception-filter"><span>异常过滤器 (Exception Filter)</span></a></h2><ul><li><p>职责：捕获和处理应用程序中抛出的异常。它是整个请求处理链的“最终错误处理程序”。</p></li><li><p>使用场景：</p><ul><li><p>捕获未被处理的异常，并返回一个用户友好的错误响应。</p></li><li><p>自定义错误响应的格式。</p></li><li><p>记录错误日志。</p></li></ul></li><li><p>特点：它不预防错误，而是响应错误。可以全局应用，也可以应用于特定的控制器或路由。</p></li></ul><h2 id="请求流程" tabindex="-1"><a class="header-anchor" href="#请求流程"><span>请求流程</span></a></h2><p>可以把 NestJS 处理请求的过程想象成一个洋葱模型（Onion Model），请求从外一层层进入，响应则从内一层层返回</p>',23)),s(l,{code:"eJxdkctOAlEMhvc8xbyAcW+MRsX7bePuhIV3F0YNalwYE0EuAzIEA4gIaFBEAjojwQCCwMvQzsxbeOhBBM+q6f+1529r2dk/PNvcW7efSGtWi8TfBAP3i16IG1oFi06bNDQ0Jk3yXA6Kl+3quxn7bNfLNkInSZximEtDKmZUND1S/IdMEWI9B1UGpQCeEqj34xcW0qxck/BOI2Sa4XUW5TzEc+BT9IZqXtaN5o3oMk3IDNPVtOkIj0hG4w2Vp2EzHzA0h0BmCJllGHwFucy74O0XlqJCnCVxjmFSAX8a+FiUnqP0/F+N0YpA4gGjH6ioApknZKHPXCjYMze6YR+DgNt4dkNYgVrE1jcXhLJUusjQnwBvDZN5DMqYuoJvJ1SrXXSBmKVzvgVegEmfUPmGOupS/4KWmdCMlhfrGe5EGFwmcYUJ62aE300bcENNft2sdjmUQ+B/HOAWxS8UH59u7NrXj/Yk8SVkXHrIw+8LTRfpxPciUdN5KxRtH2xZfgBVlg5i"})])}const u=i(a,[["render",p]]),m=JSON.parse('{"path":"/frontEnd/frameworks/Nestjs.html","title":"Nestjs","lang":"zh-CN","frontmatter":{"description":"Nestjs 查看帮助 nest --help 项目创建 nest create 项目名称 pnpm run start:dev 启动开发 nest g res <name> 生成 res 资源 重要概念 控制器@Controller: 路由, 处理传入的请求并向客户端返回响应, 必须属于某一个模块 提供器@providers: 由 Nestjs 容器...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Nestjs\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-18T00:43:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeroKing\\",\\"url\\":\\"https://github.com/Hero-King\\",\\"email\\":\\"838774057@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://blog.heroking.top/frontEnd/frameworks/Nestjs.html"}],["meta",{"property":"og:site_name","content":"HeroKing博客"}],["meta",{"property":"og:title","content":"Nestjs"}],["meta",{"property":"og:description","content":"Nestjs 查看帮助 nest --help 项目创建 nest create 项目名称 pnpm run start:dev 启动开发 nest g res <name> 生成 res 资源 重要概念 控制器@Controller: 路由, 处理传入的请求并向客户端返回响应, 必须属于某一个模块 提供器@providers: 由 Nestjs 容器..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-18T00:43:12.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-18T00:43:12.000Z"}]]},"git":{"createdTime":1758156192000,"updatedTime":1758156192000,"contributors":[{"name":"HeroKing-web","username":"HeroKing-web","email":"838774057@qq.com","commits":1,"url":"https://github.com/HeroKing-web"}]},"readingTime":{"minutes":4.2,"words":1260},"filePathRelative":"frontEnd/frameworks/Nestjs.md","excerpt":"\\n<p>查看帮助 <code>nest --help</code></p>\\n<p>项目创建</p>\\n<ul>\\n<li>nest create 项目名称</li>\\n<li>pnpm run start:dev 启动开发</li>\\n<li>nest g res <code>&lt;name&gt;</code> 生成 res 资源</li>\\n</ul>\\n<h2>重要概念</h2>\\n<ul>\\n<li>控制器@Controller: 路由, 处理传入的请求并向客户端返回响应, 必须属于某一个模块</li>\\n<li>提供器@providers: 由 Nestjs 容器管理的 js 类, 框架负责实例化, 管理其生命周期, 作为依赖注入的类</li>\\n<li>module@Module: nest 组织应用的方式, 应用至少需要有一个根模块\\n<ul>\\n<li>providers: 将由 Nest 注入器实例化并且至少可以在该模块中共享的提供程序</li>\\n<li>controllers: 此模块中定义的必须实例化的控制器集</li>\\n<li>imports: 导出此模块所需的提供程序的导入模块列表</li>\\n<li>exports: 这个模块提供的 providers 的子集应该在导入这个模块的其他模块中可用。你可以使用提供器本身或仅使用其令牌（provide 值）</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{u as comp,m as data};
