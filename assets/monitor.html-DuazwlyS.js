import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as a,o}from"./app-MIZpsOfp.js";const r={};function i(p,e){return o(),n("div",null,[...e[0]||(e[0]=[a('<h1 id="前端监控" tabindex="-1"><a class="header-anchor" href="#前端监控"><span>前端监控</span></a></h1><p>主要包括数据采集, 上报, 存储等;</p><h2 id="采集" tabindex="-1"><a class="header-anchor" href="#采集"><span>采集</span></a></h2><p>有现成的 SDK, 比如</p><ul><li><a href="https://github.com/getsentry/sentry">sentry</a> 从监控错误、错误统计图表、多重标签过滤和标签统计到触发告警，这一整套都很完善，团队项目需要充钱，而且数据量越大钱越贵</li><li><a href="https://www.fundebug.com/">fundebug</a>：除了监控错误，还可以录屏，也就是记录错误发生的前几秒用户的所有操作，压缩后的体积只有几十 KB，但操作略微繁琐</li><li><a href="https://github.com/a597873885/webfunny_monitor">webfunny</a>：也是含有监控错误的功能，可以支持千万级别日 PV 量，额外的亮点是可以远程调试、性能分析，也可以 docker 私有化部署（免费），业务代码加密过</li><li>百度统计： 一键接入，但是无业务数据</li></ul><h3 id="性能监控" tabindex="-1"><a class="header-anchor" href="#性能监控"><span>性能监控</span></a></h3><ul><li>fp 表示渲染出第一个像素点。FP 一般在 HTML 解析完成或者解析一部分时候触发</li><li>fcp（First Contentful Paint），表示渲染出第一个内容，这里的&quot;内容&quot;可以是文本、图片、canvas</li><li>lcp （largest contentful Paint），最大内容渲染时间</li><li>资源加载时间</li><li>接口请求时间</li></ul><h3 id="错误监控" tabindex="-1"><a class="header-anchor" href="#错误监控"><span>错误监控</span></a></h3><ul><li>资源加载出错 使用 window.addEventListener(&#39;error&#39;, cb, true) 判断 error.target</li><li>JS 错误 使用 window.onerror = (message,source,lineno,colno,error){}</li><li>Promise 错误 使用 window.addEventListener(&quot;unhandledrejection&quot;, cb)</li></ul><h3 id="用户行为" tabindex="-1"><a class="header-anchor" href="#用户行为"><span>用户行为</span></a></h3><ul><li>pv</li><li>uv</li><li>页面停留时间</li></ul><h2 id="上报" tabindex="-1"><a class="header-anchor" href="#上报"><span>上报</span></a></h2><ul><li>方法 常规使用 1*1 透明的 gif 图片; 使用 navigator.sendBeacon 发送 post 请求 <blockquote><p>为什么要使用 gif 图片???<br> 没有跨域问题； 不会阻塞页面加载，影响用户体验； 在所有图片中体积最小，相较 BMP/PNG，可以节约 41%/35%的网络资源。</p></blockquote></li><li>时机 <ol><li>settimeout 延迟上报</li><li>beforeunload</li><li>前端缓存数据, 达到一定程度后统一上报 合并上报</li></ol></li></ul><h2 id="应用发布" tabindex="-1"><a class="header-anchor" href="#应用发布"><span>应用发布</span></a></h2><blockquote><p>参考资料： <a href="https://www.cnblogs.com/mq0036/p/14306444.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/mq0036/p/14306444.html</a></p></blockquote><h3 id="金丝雀发布-一台-剩余" tabindex="-1"><a class="header-anchor" href="#金丝雀发布-一台-剩余"><span>金丝雀发布(一台-&gt;剩余)</span></a></h3><p>金丝雀发布是灰度发布的一种。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。即在发布过程中一部分用户继续使用老版本，一部分用户使用新版本，不断地扩大新版本的访问流量。最终实现老版本到新版本的过度。</p><p>缺点：是一次性的全量发布，发布过程中用户体验并不平滑，有些隐藏深处的bug少量用户可能并不能验证出来问题，需要逐步扩大流量才可以。</p><h3 id="滚动发布-一台-一台-一台" tabindex="-1"><a class="header-anchor" href="#滚动发布-一台-一台-一台"><span>滚动发布(一台-&gt;一台-&gt;一台)</span></a></h3><p>相比于金丝雀发布，先发金丝雀，然后全发的方式，滚动发布则是整个发布过程中按批次进行发布。每个批次拉入后都可作为金丝雀进行验证，这样流量逐步放大直至结束。</p><p>缺点：是发布和回退时间慢，其次发布工具复杂，负载均衡设备需要具有平滑的拉入拉出能力，一般公司并没有资源投入研发这种复杂的发布工具。再者发布过程中新老版本同时运行，需要注意兼容性问题。</p><h3 id="蓝绿发布-流量切集群1-发布集群2-流量切集群2-发布集群1-流量走集群1-2" tabindex="-1"><a class="header-anchor" href="#蓝绿发布-流量切集群1-发布集群2-流量切集群2-发布集群1-流量走集群1-2"><span>蓝绿发布(流量切集群1-&gt;发布集群2-&gt;流量切集群2-&gt;发布集群1-&gt;流量走集群1,2)</span></a></h3><p>是采用两个分开的集群对软件版本进行升级的一种方式。它的部署模型中包括一个蓝色集群 Group1 和一个绿色集群 Group2，在没有新版本上线的情况下，两个集群上运行的版本是一致的，同时对外提供服务。</p><p>缺点：全量升级，如果V2版本有问题，对用户影响大再者由于升级过程中会服务器资源会减少一半，有可能产生服务器过载问题，不适用于在业务高峰期使用</p><h3 id="红黑发布" tabindex="-1"><a class="header-anchor" href="#红黑发布"><span>红黑发布</span></a></h3><p>申请一个黑色集群 Group2 ，在 Group2 上部署新版本的服务；等到 Group2 升级完成后，我们一次性地把负载均衡全部指向 Group2 ；把 Group1 集群从负载均衡列表中删除，并释放集群 Group1 中所有机器。</p><h3 id="功能开关" tabindex="-1"><a class="header-anchor" href="#功能开关"><span>功能开关</span></a></h3><p>利用代码中的功能开关来控制发布逻辑，是一种相对比较低成本和简单的发布方式。研发人员可以灵活定制和自助完成的发布方式。这种方式通常依赖于一个配置中心系统，当然如果没有，可以使用简单的配置文件。</p>',28)])])}const h=t(r,[["render",i]]),c=JSON.parse('{"path":"/frontEnd/optimization/monitor.html","title":"前端监控","lang":"zh-CN","frontmatter":{"description":"前端监控 主要包括数据采集, 上报, 存储等; 采集 有现成的 SDK, 比如 sentry 从监控错误、错误统计图表、多重标签过滤和标签统计到触发告警，这一整套都很完善，团队项目需要充钱，而且数据量越大钱越贵 fundebug：除了监控错误，还可以录屏，也就是记录错误发生的前几秒用户的所有操作，压缩后的体积只有几十 KB，但操作略微繁琐 webfun...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"前端监控\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-18T00:43:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeroKing\\",\\"url\\":\\"https://github.com/Hero-King\\",\\"email\\":\\"838774057@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://blog.heroking.top/frontEnd/optimization/monitor.html"}],["meta",{"property":"og:site_name","content":"HeroKing博客"}],["meta",{"property":"og:title","content":"前端监控"}],["meta",{"property":"og:description","content":"前端监控 主要包括数据采集, 上报, 存储等; 采集 有现成的 SDK, 比如 sentry 从监控错误、错误统计图表、多重标签过滤和标签统计到触发告警，这一整套都很完善，团队项目需要充钱，而且数据量越大钱越贵 fundebug：除了监控错误，还可以录屏，也就是记录错误发生的前几秒用户的所有操作，压缩后的体积只有几十 KB，但操作略微繁琐 webfun..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-18T00:43:12.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-18T00:43:12.000Z"}]]},"git":{"createdTime":1758156192000,"updatedTime":1758156192000,"contributors":[{"name":"HeroKing-web","username":"HeroKing-web","email":"838774057@qq.com","commits":1,"url":"https://github.com/HeroKing-web"}]},"readingTime":{"minutes":3.81,"words":1143},"filePathRelative":"frontEnd/optimization/monitor.md","excerpt":"\\n<p>主要包括数据采集, 上报, 存储等;</p>\\n<h2>采集</h2>\\n<p>有现成的 SDK, 比如</p>\\n<ul>\\n<li><a href=\\"https://github.com/getsentry/sentry\\">sentry</a> 从监控错误、错误统计图表、多重标签过滤和标签统计到触发告警，这一整套都很完善，团队项目需要充钱，而且数据量越大钱越贵</li>\\n<li><a href=\\"https://www.fundebug.com/\\">fundebug</a>：除了监控错误，还可以录屏，也就是记录错误发生的前几秒用户的所有操作，压缩后的体积只有几十 KB，但操作略微繁琐</li>\\n<li><a href=\\"https://github.com/a597873885/webfunny_monitor\\">webfunny</a>：也是含有监控错误的功能，可以支持千万级别日 PV 量，额外的亮点是可以远程调试、性能分析，也可以 docker 私有化部署（免费），业务代码加密过</li>\\n<li>百度统计： 一键接入，但是无业务数据</li>\\n</ul>","autoDesc":true}');export{h as comp,c as data};
