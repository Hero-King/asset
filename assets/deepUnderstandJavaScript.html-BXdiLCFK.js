import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,o as i}from"./app-XKCljP8-.js";const l={};function p(r,n){return i(),a("div",null,[...n[0]||(n[0]=[e(`<h1 id="深入理解-javascript" tabindex="-1"><a class="header-anchor" href="#深入理解-javascript"><span>深入理解 javascript</span></a></h1><p>参考链接： 汤姆大叔 <a href="https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html</a><br> W3C <a href="https://www.w3cschool.cn/deep_learn_javascript/deep_learn_javascript-1sry284r.html" target="_blank" rel="noopener noreferrer">https://www.w3cschool.cn/deep_learn_javascript/deep_learn_javascript-1sry284r.html</a></p><h3 id="编写高质量-javascript-代码的基本要点" tabindex="-1"><a class="header-anchor" href="#编写高质量-javascript-代码的基本要点"><span>编写高质量 JavaScript 代码的基本要点</span></a></h3><ul><li>避免使用全局变量</li><li>合理使用 hasOwnProperty</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>// 1.</span></span>
<span class="line"><span>// for-in 循环</span></span>
<span class="line"><span>for (var i in man) {</span></span>
<span class="line"><span>   if (man.hasOwnProperty(i)) { // 过滤</span></span>
<span class="line"><span>      console.log(i, &quot;:&quot;, man[i]);</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>/* 控制台显示结果</span></span>
<span class="line"><span>hands : 2</span></span>
<span class="line"><span>legs : 2</span></span>
<span class="line"><span>heads : 1</span></span>
<span class="line"><span>*/</span></span>
<span class="line"><span>// 2.</span></span>
<span class="line"><span>// 反面例子:</span></span>
<span class="line"><span>// for-in loop without checking hasOwnProperty()</span></span>
<span class="line"><span>for (var i in man) {</span></span>
<span class="line"><span>   console.log(i, &quot;:&quot;, man[i]);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>/*</span></span>
<span class="line"><span>控制台显示结果</span></span>
<span class="line"><span>hands : 2</span></span>
<span class="line"><span>legs : 2</span></span>
<span class="line"><span>heads : 1</span></span>
<span class="line"><span>clone: function()</span></span>
<span class="line"><span>*/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>parseInt()下的数值转换总是指定基数参数。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>var month = &quot;06&quot;,</span></span>
<span class="line"><span>    year = &quot;09&quot;;</span></span>
<span class="line"><span>month = parseInt(month, 10);</span></span>
<span class="line"><span>year = parseInt(year, 10);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用一个下划线前缀来表示一个私有属性或方法</li></ul><h3 id="揭秘命名函数表达式" tabindex="-1"><a class="header-anchor" href="#揭秘命名函数表达式"><span>揭秘命名函数表达式</span></a></h3><p>var f = function foo(){<br> return typeof foo; // foo 是在内部作用域内有效<br> };<br> // foo 在外部用于是不可见的<br> typeof foo; // &quot;undefined&quot;<br> f(); // &quot;function&quot;</p><ul><li>JScript 的内存管理</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>  var f = (function(){</span></span>
<span class="line"><span>    if (true) {</span></span>
<span class="line"><span>      return function g(){};</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return function g(){};</span></span>
<span class="line"><span>  })();</span></span>
<span class="line"><span>  我们知道，这个匿名函数调用返回的函数（带有标识符g的函数），然后赋值给了外部的f。我们也知道，命名函数表达式会导致产生多余的函数对象，而该对象与返回的函数对象不是一回事。所以这个多余的g函数就死在了返回函数的闭包中了，因此内存问题就出现了。这是因为if语句内部的函数与g是在同一个作用域中被声明的。这种情况下 ，除非我们显式断开对g函数的引用，否则它一直占着内存不放。</span></span>
<span class="line"><span>    var f = (function(){</span></span>
<span class="line"><span>        var f, g;</span></span>
<span class="line"><span>        if (true) {</span></span>
<span class="line"><span>          f = function g(){};</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>          f = function g(){};</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 设置g为null以后它就不会再占内存了</span></span>
<span class="line"><span>        g = null;</span></span>
<span class="line"><span>        return f;</span></span>
<span class="line"><span>  })();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  其实，如果我们不想要这个描述性名字的话，我们就可以用最简单的形式来做，也就是在函数内部声明一个函数（而不是函数表达式），然后返回该函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>自执行函数</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>// 下面2个括弧()都会立即执行</span></span>
<span class="line"><span></span></span>
<span class="line"><span>(function () { /* code */ } ()); // 推荐使用这个</span></span>
<span class="line"><span>(function () { /* code */ })(); // 但是这个也是可以用的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链"><span>原型链</span></a></h3><p>原型对象也是普通的对象，并且也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链（prototype chain）。</p><h3 id="执行上下文栈" tabindex="-1"><a class="header-anchor" href="#执行上下文栈"><span>执行上下文栈</span></a></h3><p>在 ECMASscript 中的代码有三种类型：global, function 和 eval。</p><p>每一种代码的执行都需要依赖自身的上下文。当然 global 的上下文可能涵盖了很多的 function 和 eval 的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval 函数的每一次执行，也会进入 eval 执行中的上下文，判断应该从何处获取变量的值。</p><p>注意，一个 function 可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。</p><p>一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数(或者全局的上下文调用了一个全局函数)，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为<strong>上下文堆栈</strong>。</p><h3 id="执行上下文-execution-context" tabindex="-1"><a class="header-anchor" href="#执行上下文-execution-context"><span>执行上下文(Execution Context)</span></a></h3><p>一个执行的上下文可以抽象的理解为 object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。主要有这三个属性 (变量对象(variable object)，this 指针(this value)，作用域链(scope chain) ),除了这 3 个所需要的属性,执行上下文根据具体实现还可以具有任意额外属性。</p><ul><li>变量对象 变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。<br> 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。函数表达式[function expression]是不包含在 VO[variable object]里面的</li><li>作用域链 是一个对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers)标示符[Identifiers]可以理解为变量名称、函数声明和普通参数。 。作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</li></ul><h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h3><p>是一系列代码块（在 ECMAScript 中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</p>`,26)])])}const d=s(l,[["render",p]]),o=JSON.parse('{"path":"/books/deepUnderstandJavaScript.html","title":"深入理解 javascript","lang":"zh-CN","frontmatter":{"description":"深入理解 javascript 参考链接： 汤姆大叔 https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html W3C https://www.w3cschool.cn/deep_learn_javascript/deep_learn_javascript-1sry284r.html 编...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"深入理解 javascript\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-22T06:00:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeroKing\\",\\"url\\":\\"https://github.com/Hero-King\\",\\"email\\":\\"838774057@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://blog.heroking.top/books/deepUnderstandJavaScript.html"}],["meta",{"property":"og:site_name","content":"HeroKing博客"}],["meta",{"property":"og:title","content":"深入理解 javascript"}],["meta",{"property":"og:description","content":"深入理解 javascript 参考链接： 汤姆大叔 https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html W3C https://www.w3cschool.cn/deep_learn_javascript/deep_learn_javascript-1sry284r.html 编..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-22T06:00:26.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-22T06:00:26.000Z"}]]},"git":{"createdTime":1758520826000,"updatedTime":1758520826000,"contributors":[{"name":"HeroKing-web","username":"HeroKing-web","email":"838774057@qq.com","commits":1,"url":"https://github.com/HeroKing-web"}]},"readingTime":{"minutes":4.02,"words":1206},"filePathRelative":"books/deepUnderstandJavaScript.md","excerpt":"\\n<p>参考链接： 汤姆大叔 <a href=\\"https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html</a><br>\\nW3C <a href=\\"https://www.w3cschool.cn/deep_learn_javascript/deep_learn_javascript-1sry284r.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.w3cschool.cn/deep_learn_javascript/deep_learn_javascript-1sry284r.html</a></p>","autoDesc":true}');export{d as comp,o as data};
