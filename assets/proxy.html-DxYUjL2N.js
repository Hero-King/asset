import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,o as i}from"./app-BqIpQNrN.js";const p={};function l(t,s){return i(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="代理和内网穿透" tabindex="-1"><a class="header-anchor" href="#代理和内网穿透"><span>代理和内网穿透</span></a></h1><h2 id="代理" tabindex="-1"><a class="header-anchor" href="#代理"><span>代理</span></a></h2><p>主要有以下几种</p><ul><li>正向代理: 代理客户端去请求服务器</li><li>反向代理: 代理服务端, 用户请求的是代理服务器, 代理服务器请求真实目的主机</li></ul><p>按照代理方式, 目前主要有 http 代理, socks 代理, 对于目前主流的 Https 协议, http 代理无能为力</p><h2 id="代理软件" tabindex="-1"><a class="header-anchor" href="#代理软件"><span>代理软件</span></a></h2><ul><li>gost</li><li>v2ray</li></ul><h2 id="内网穿透" tabindex="-1"><a class="header-anchor" href="#内网穿透"><span>内网穿透</span></a></h2><p>内网穿透又叫 nat 穿透, 本质就是解决 ipv4 供应不足问题<br> 正常上网路径: 内网设备 -&gt; 内网设备 -&gt; ... -&gt; 运营商公网机器 nat -&gt; 服务器 -&gt; 运营商公网机器 nat -&gt; 内网设备 -&gt; ... -&gt; 内网设备<br> 也就是可以从外网访问到内网机器的<br> 内网穿透原理就是这个<br> 内网服务器先和公网 IP 机器建立连接 后面由客户端请求到公网服务器 IP:PORT 公网机器把请求转发到之前建立的连接中 达到访问内网服务器的目的 但是常见的内网穿透软件(花生壳 frp) 都是针对<strong>端口进行转发</strong><br> 想要访问内网机器 可以使用 VPN 、 v2ray 反向代理</p><h2 id="openvpn" tabindex="-1"><a class="header-anchor" href="#openvpn"><span>openvpn</span></a></h2><p><a href="https://www.ilanni.com/?p=9837" target="_blank" rel="noopener noreferrer">https://www.ilanni.com/?p=9837</a> 烂泥写的挺好的</p><h2 id="pptp" tabindex="-1"><a class="header-anchor" href="#pptp"><span>PPTP</span></a></h2><p>docker run --name pptpd --privileged --net=host -d -p 1723:1723 -v /etc/ppp/chap-secrets:/etc/ppp/chap-secrets:ro whuwxl/pptpd<br> 端口 1723 映射</p><h2 id="ipsec-vpn-l2tp" tabindex="-1"><a class="header-anchor" href="#ipsec-vpn-l2tp"><span>ipsec-vpn/L2tp</span></a></h2><p><a href="https://github.com/hwdsl2/setup-ipsec-vpn" target="_blank" rel="noopener noreferrer">https://github.com/hwdsl2/setup-ipsec-vpn</a><br> ipsec 是对 l2tp 基础上加密处理<br> 路由器上的服务端是 l2tp 不带 ipsec 所以 windows 客户端设置的时候 [安全] 高级设置不选 PSC 秘钥,不选证书验证,数据加密不加密 默认 vpn 是全局流量代理<br> L2TP 需开放端口：<br> UDP:500<br> UDP:4500<br> UDP:1701</p><h2 id="使用-frp-内网穿透-esxi" tabindex="-1"><a class="header-anchor" href="#使用-frp-内网穿透-esxi"><span>使用 frp 内网穿透 esxi</span></a></h2><ul><li><p>1024 以下端口需要使用 root 用户启动 frps (注释 frps.service 中的 User=nobody)</p></li><li><p>frps 服务注册 /usr/lib/systemd/system/frps.service</p></li><li><p>frpc 映射 443 和 902 端口</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>[esxi-web]</span></span>
<span class="line"><span>remote_port = 9443</span></span>
<span class="line"><span>type = tcp</span></span>
<span class="line"><span>local_ip = 192.168.123.100</span></span>
<span class="line"><span>local_port = 443</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[esxi-client-windowt]</span></span>
<span class="line"><span>remote_port = 902</span></span>
<span class="line"><span>type = tcp</span></span>
<span class="line"><span>local_ip = 192.168.123.100</span></span>
<span class="line"><span>local_port = 902</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>nginx 设置 301 重定向 http 转 https</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>server {</span></span>
<span class="line"><span>        listen       80;</span></span>
<span class="line"><span>        listen       [::]:80;</span></span>
<span class="line"><span>        server_name  _;</span></span>
<span class="line"><span>        # rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。</span></span>
<span class="line"><span>        # $host代表请求头中的host $server_name代表上面匹配的虚拟主机名称(即_)</span></span>
<span class="line"><span>        return 301 https://$host$request_uri;</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>多域名解析到真实主机<br> 我设置 esxi.domain 解析到主机,申请域名免费 ssl 证书</p></li><li><p>nginx 配置虚拟主机<br><strong>注意 nginx 是否支持 TLS SNI (nginx -V 查看 TLS SNI support enabled)</strong><br> 如果不支持 需要将 esxi 的虚拟 server 段放在最上面 当成默认的虚拟主机 应为 vmware 客户端不支持 SNI</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span> server {</span></span>
<span class="line"><span>   listen       443 ssl ;</span></span>
<span class="line"><span>   listen       [::]:443 ssl ;</span></span>
<span class="line"><span>   server_name  域名;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   ssl_certificate &quot;/etc/pki/nginx/XXX.pem&quot;;</span></span>
<span class="line"><span>   ssl_certificate_key &quot;/etc/pki/nginx/private/XXX.key&quot;;</span></span>
<span class="line"><span>   ssl_session_timeout  10m;</span></span>
<span class="line"><span>   ssl_ciphers HIGH:!aNULL:!MD5;</span></span>
<span class="line"><span>   ssl_prefer_server_ciphers on;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    location / {</span></span>
<span class="line"><span>        proxy_pass https://127.0.0.1:port;</span></span>
<span class="line"><span>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span></span>
<span class="line"><span>        proxy_set_header Host $host;</span></span>
<span class="line"><span>        # proxy_set_header X-Forward-Proto https;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        proxy_http_version 1.1;</span></span>
<span class="line"><span>        proxy_set_header Upgrade $http_upgrade;</span></span>
<span class="line"><span>        proxy_set_header Connection &quot;upgrade&quot;;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span># ...其他虚拟主机</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,17)])])}const d=n(p,[["render",l]]),o=JSON.parse('{"path":"/network/proxy.html","title":"代理和内网穿透","lang":"zh-CN","frontmatter":{"description":"代理和内网穿透 代理 主要有以下几种 正向代理: 代理客户端去请求服务器 反向代理: 代理服务端, 用户请求的是代理服务器, 代理服务器请求真实目的主机 按照代理方式, 目前主要有 http 代理, socks 代理, 对于目前主流的 Https 协议, http 代理无能为力 代理软件 gost v2ray 内网穿透 内网穿透又叫 nat 穿透, 本...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"代理和内网穿透\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-07T06:23:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeroKing\\",\\"url\\":\\"https://github.com/Hero-King\\",\\"email\\":\\"838774057@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://blog.heroking.top/network/proxy.html"}],["meta",{"property":"og:site_name","content":"HeroKing博客"}],["meta",{"property":"og:title","content":"代理和内网穿透"}],["meta",{"property":"og:description","content":"代理和内网穿透 代理 主要有以下几种 正向代理: 代理客户端去请求服务器 反向代理: 代理服务端, 用户请求的是代理服务器, 代理服务器请求真实目的主机 按照代理方式, 目前主要有 http 代理, socks 代理, 对于目前主流的 Https 协议, http 代理无能为力 代理软件 gost v2ray 内网穿透 内网穿透又叫 nat 穿透, 本..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-07T06:23:39.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-07T06:23:39.000Z"}]]},"git":{"createdTime":1757226219000,"updatedTime":1757226219000,"contributors":[{"name":"HeroKingMini","username":"HeroKingMini","email":"838774057@qq.com","commits":1,"url":"https://github.com/HeroKingMini"}]},"readingTime":{"minutes":2.36,"words":708},"filePathRelative":"network/proxy.md","excerpt":"\\n<h2>代理</h2>\\n<p>主要有以下几种</p>\\n<ul>\\n<li>正向代理: 代理客户端去请求服务器</li>\\n<li>反向代理: 代理服务端, 用户请求的是代理服务器, 代理服务器请求真实目的主机</li>\\n</ul>\\n<p>按照代理方式, 目前主要有 http 代理, socks 代理, 对于目前主流的 Https 协议, http 代理无能为力</p>\\n<h2>代理软件</h2>\\n<ul>\\n<li>gost</li>\\n<li>v2ray</li>\\n</ul>\\n<h2>内网穿透</h2>\\n<p>内网穿透又叫 nat 穿透, 本质就是解决 ipv4 供应不足问题<br>\\n正常上网路径: 内网设备 -&gt; 内网设备 -&gt; ... -&gt; 运营商公网机器 nat -&gt; 服务器 -&gt; 运营商公网机器 nat -&gt; 内网设备 -&gt; ... -&gt; 内网设备<br>\\n也就是可以从外网访问到内网机器的<br>\\n内网穿透原理就是这个<br>\\n内网服务器先和公网 IP 机器建立连接 后面由客户端请求到公网服务器 IP:PORT 公网机器把请求转发到之前建立的连接中 达到访问内网服务器的目的 但是常见的内网穿透软件(花生壳 frp) 都是针对<strong>端口进行转发</strong><br>\\n想要访问内网机器 可以使用 VPN 、 v2ray 反向代理</p>","autoDesc":true}');export{d as comp,o as data};
