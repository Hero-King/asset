(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{494:function(s,e,t){"use strict";t.r(e);var l=t(33),u=Object(l.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h3",{attrs:{id:"github-提供的主要功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#github-提供的主要功能"}},[s._v("#")]),s._v(" GitHub 提供的主要功能")]),s._v(" "),e("ul",[e("li",[s._v("Git 仓库")]),s._v(" "),e("li",[s._v("Issue")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("Issue 功能，是将一个任务或问题分配给一个 Issue 进行追踪和管理\n的功能。可以像 BUG 管理系统或 TiDD（Ticket-driven Development）的\nTicket 一样使用。\n每一个功能更改或修正都对应一个 Issue，讨论或修正都以这个\nIssue 为中心进行。只要查看 Issue，就能知道和这个更改相关的一切信\n息，并以此进行管理。\n在 Git 的提交信息中写上 Issue 的 ID（例如“#7”），GitHub 就会自\n动生成从 Issue 到对应提交的链接。另外，只要按照特定的格式描述提\n交信息，还可以关闭 Issue。\n")])])]),e("ul",[e("li",[s._v("Wiki")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("通过 Wiki 功能，任何人都能随时对一篇文章进行更改并保存，因\n此可以多人共同完成一篇文章。该功能常用在开发文档或手册的编写\n中。同时支持git管理\n")])])]),e("ul",[e("li",[s._v("Pull Request")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("开发者向 GitHub 的仓库推送更改或功能添加后，可以通过 Pull\nRequest 功能向别人的仓库提出申请，请求对方合并。\n\n")])])]),e("h3",{attrs:{id:"实际操作学习-git"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实际操作学习-git"}},[s._v("#")]),s._v(" 实际操作学习 git")]),s._v(" "),e("p",[s._v("git diff 查看工作树和暂存区的差别\ngit diff HEAD 查看工作树和最新提交的差别\ngit branch 显示分支一览表\ngit log --graph——以图表形式查看分支\ngit reflog 命令恢复到原先的状态\ngit commit --amend——修改提交信息")]),s._v(" "),e("p",[s._v("在日常开发中,往往会创建数个特性分支,同时在\n此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常\n由 master 分支担当")]),s._v(" "),e("h3",{attrs:{id:"issue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#issue"}},[s._v("#")]),s._v(" Issue")]),s._v(" "),e("p",[s._v("开发者们为了跟踪 BUG 及进行软件相关讨论,进而方便管理,创建了 Issue。")]),s._v(" "),e("ul",[e("li",[s._v("发现软件的 BUG 并报告")]),s._v(" "),e("li",[s._v("有事想向作者询问、探讨")]),s._v(" "),e("li",[s._v("事先列出今后准备实施的任务")])]),s._v(" "),e("p",[s._v("Issue 可以通过添加标签(Label)来进行整理。")]),s._v(" "),e("h4",{attrs:{id:"通过提交信息操作-issue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过提交信息操作-issue"}},[s._v("#")]),s._v(" 通过提交信息操作 Issue")]),s._v(" "),e("ul",[e("li",[s._v("在相关 Issue 中显示提交\n在 Issue 一览表中我们可以看到,每一个 Issue 标题的下面都分配了\n诸如“#24”的编号。只要在提交信息的描述中加入“#24”,就可以如\n图 5.18 所示,在 Issue 中显示该提交的相关信息,使关联的提交一目了\n然。这里只需轻轻点击一下便可以显示相应提交的具体内容,在代码审\n查时省去了从大量提交日志中搜索相应提交的麻烦,非常方便。")]),s._v(" "),e("li",[s._v("Close Issue\n只要在该提交中以下列任意一种格式描述提交信息,对应的 Issue 就会被 Close。 fix #24 fixes #24 fixed #24 close #24 closed #24 resolve #24 resolved #24 等等")])]),s._v(" "),e("p",[s._v("Tasklist 语法 #本月要做的任务")]),s._v(" "),e("ul",[e("li",[s._v("[ ] 完成图片")]),s._v(" "),e("li",[s._v("[x] 完成部署工具的设置 --\x3e 复选列表的样式")]),s._v(" "),e("li",[s._v("[ ] 实现抽签功能")])]),s._v(" "),e("h3",{attrs:{id:"pull-request"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pull-request"}},[s._v("#")]),s._v(" Pull Request")]),s._v(" "),e("p",[s._v("Pull Request 是自己修改源代码后,请求对方仓库采纳该修改时采取的一种行为。\n"),e("img",{attrs:{src:"img/pull request概念图.png"}})]),s._v(" "),e("ul",[e("li",[s._v("Fork 到自己仓库 Pull Request")])]),s._v(" "),e("ol",[e("li",[s._v("fork 原来的仓库（resource）到自己的 github 中")]),s._v(" "),e("li",[s._v("clone 代码,新建特性分支专注解决这个问题")]),s._v(" "),e("li",[s._v("本地修改代码，解决 bug，后提交代码到自己的仓库中")]),s._v(" "),e("li",[s._v("在仓库中发起 pull request 请求，请求 resource 仓库合并我的代码")]),s._v(" "),e("li",[s._v("resource 仓库管理员审核代码，测试代码后通过即可合并")])]),s._v(" "),e("p",[s._v("向发送过 Pull Request 的分支添加提交时,该提交会自动添加至已\n发送的 Pull Request 中。 这一方法要求尽早发送 Pull Request,越早效果越明显。")]),s._v(" "),e("ul",[e("li",[s._v("不进行 Fork 直接从分支发送 Pull Request\n如果用户对该仓库有编辑权限,则可以直接创建分支,从分支发送 Pull Request。\n利用这一设计,团队开发时不妨为每一名成员赋予编辑权限,免去 Fork 仓库的麻烦。这样,成员在有需要时就可以创建自己的分支,然后直接向 master 分支等发送 Pull Request。")])]),s._v(" "),e("p",[s._v("补充: 版本号\n版本号的分配规则\n版本控制策略规定了软件版本号的分配规则，因此制定该策\n略时应当尽量简单易懂。\n比如在用 x.y.z 格式进行版本管理时的规则如下所示。\n● …x 在重大功能变更或新版本不向下兼容时加 1，此时 y 与 z\n的数字归 0\n● y 在添加新功能或者删除已有功能时加 1，此时 z 的数字归 0\n● z 只在进行内部修改后加 1\n下面举个具体例子。\n● 1.0.0：最初发布的版本\n● 1.0.1：修正了轻微 BUG\n● 1.0.2：修复漏洞\n● 1.1.0：添加新功能\n● 2.0.0：更新整体 UI 并添加新功能\n这便是版本号的大致分配规则。\n如果团队采用了 Git…Flow，那么成员在交流的时候会经常用\n到版本号，因此版本控制策略越早制定越好。")])])}),[],!1,null,null,null);e.default=u.exports}}]);