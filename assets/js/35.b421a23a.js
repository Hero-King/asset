(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{445:function(t,e,v){"use strict";v.r(e);var s=v(33),_=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"全栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全栈"}},[t._v("#")]),t._v(" 全栈")]),t._v(" "),e("p",[t._v("如何成为一个全栈工程师? 前端开发何去何从")]),t._v(" "),e("h2",{attrs:{id:"js-框架概览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-框架概览"}},[t._v("#")]),t._v(" JS 框架概览")]),t._v(" "),e("h3",{attrs:{id:"前端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端"}},[t._v("#")]),t._v(" 前端")]),t._v(" "),e("ul",[e("li",[t._v("nuxt.js 用于 Vue 服务端渲染, 静态站点的框架")]),t._v(" "),e("li",[t._v("next.js 用于 React 服务端渲染,静态站点,客户端渲染的框架")])]),t._v(" "),e("h3",{attrs:{id:"后端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后端"}},[t._v("#")]),t._v(" 后端")]),t._v(" "),e("ul",[e("li",[t._v("express")]),t._v(" "),e("li",[t._v("nest 基于 express,类似于 spring 框架, Nest.js 是一个基于 TypeScript 的 Node.js 后端框架，它结合了 OOP（面向对象编程）、FP（函数式编程）和 FRP（函数式响应式编程）等概念，提供了一个优雅且强大的开发平台。")])]),t._v(" "),e("h4",{attrs:{id:"nodejs-orm-框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-orm-框架"}},[t._v("#")]),t._v(" nodejs orm 框架")]),t._v(" "),e("ul",[e("li",[t._v("TypeORM 是一个面向 TypeScript 和 JavaScript 的 ORM 框架，它支持多种数据库，包括 MySQL、PostgreSQL、SQLite 和 Microsoft SQL Server。它提供了实体映射、关联关系、事务支持等功能。")]),t._v(" "),e("li",[t._v("Sequelize: Sequelize 是一个基于 Promise 的 ORM 框架，支持多种数据库，包括 MySQL、PostgreSQL、SQLite 和 MSSQL。它提供了丰富的功能，包括模型定义、关联关系、事务支持、数据验证等")])]),t._v(" "),e("h2",{attrs:{id:"技术选型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#技术选型"}},[t._v("#")]),t._v(" 技术选型")]),t._v(" "),e("ul",[e("li",[t._v("nestjs + typeorm + mysql 进阶后端开发 "),e("code",[t._v("npm install --save @nestjs/typeorm typeorm mysql2")])])]),t._v(" "),e("h3",{attrs:{id:"nestjs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nestjs"}},[t._v("#")]),t._v(" Nestjs")]),t._v(" "),e("p",[t._v("查看帮助 "),e("code",[t._v("nest --help")])]),t._v(" "),e("p",[t._v("项目创建")]),t._v(" "),e("ul",[e("li",[t._v("nest create 项目名称")]),t._v(" "),e("li",[t._v("pnpm run start:dev 启动开发")]),t._v(" "),e("li",[t._v("nest g res "),e("code",[t._v("<name>")]),t._v(" 生成 res 资源")])]),t._v(" "),e("h3",{attrs:{id:"重要概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重要概念"}},[t._v("#")]),t._v(" 重要概念")]),t._v(" "),e("ul",[e("li",[t._v("控制器@Controller: 路由, 处理传入的请求并向客户端返回响应, 必须属于某一个模块")]),t._v(" "),e("li",[t._v("提供器@providers: 由 Nestjs 容器管理的 js 类, 框架负责实例化, 管理其生命周期, 作为依赖注入的类")]),t._v(" "),e("li",[t._v("module@Module: nest 组织应用的方式, 应用至少需要有一个根模块\n"),e("ul",[e("li",[t._v("providers: 将由 Nest 注入器实例化并且至少可以在该模块中共享的提供程序")]),t._v(" "),e("li",[t._v("controllers: 此模块中定义的必须实例化的控制器集")]),t._v(" "),e("li",[t._v("imports: 导出此模块所需的提供程序的导入模块列表")]),t._v(" "),e("li",[t._v("exports: 这个模块提供的 providers 的子集应该在导入这个模块的其他模块中可用。你可以使用提供器本身或仅使用其令牌（provide 值）")])])])]),t._v(" "),e("h3",{attrs:{id:"directories"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#directories"}},[t._v("#")]),t._v(" Directories")]),t._v(" "),e("ul",[e("li",[t._v("src/main.ts 应用程序的入口文件，它使用核心函数 NestFactory 来创建 Nest 应用程序实例。")]),t._v(" "),e("li",[t._v("src/app.module.ts\t应用程序的根模块。")]),t._v(" "),e("li",[t._v("src/app.controller.ts\t一个具有单个路由的基本控制器。")]),t._v(" "),e("li",[t._v("src/app.service.ts\t一个具有单个方法的基本服务。")])]),t._v(" "),e("h3",{attrs:{id:"模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[t._v("#")]),t._v(" 模块")]),t._v(" "),e("p",[t._v("下述中的 "),e("code",[t._v("js类")]),t._v(" 其实是为框架读取使用, 真正导出导入的是容器中帮我们创建好的实例")]),t._v(" "),e("ul",[e("li",[t._v("共享模块: 使用 @Module.exports 导出 "),e("code",[t._v("js类")]),t._v(", 其他需要使用的模块中 @Module.import")]),t._v(" "),e("li",[t._v("全局模块: 在模块上使用@Global()注解, 其他模块直接注入"),e("code",[t._v("js类")]),t._v("即可, 不需要在@Module.import")]),t._v(" "),e("li",[t._v("动态模块: 编写模块类, 实现forRoot静态方法, 返回模块配置对象即可")])]),t._v(" "),e("h3",{attrs:{id:"中间件-middleware"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中间件-middleware"}},[t._v("#")]),t._v(" 中间件 (Middleware)")]),t._v(" "),e("ul",[e("li",[t._v("职责：最基础的层面。处理请求和响应对象，执行任何代码，对请求和响应进行更改。它可以结束请求-响应周期（比如权限验证失败直接返回 403）。")]),t._v(" "),e("li",[t._v("使用场景：\n"),e("ul",[e("li",[t._v("CORS (跨域资源共享)")]),t._v(" "),e("li",[t._v("日志记录 (Morgan)")]),t._v(" "),e("li",[t._v("请求体解析 (BodyParser)")]),t._v(" "),e("li",[t._v("Cookie / Session 处理")])])]),t._v(" "),e("li",[t._v("特点：最通用，但职责不明确，什么都能做。")])]),t._v(" "),e("h3",{attrs:{id:"守卫-guard"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#守卫-guard"}},[t._v("#")]),t._v(" 守卫 (Guard)")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("职责：路由守卫。只有一个核心任务——决定一个请求是否应该由路由处理程序处理。它通常实现 CanActivate 接口，返回一个布尔值。")])]),t._v(" "),e("li",[e("p",[t._v("使用场景：")]),t._v(" "),e("ul",[e("li",[t._v("身份认证 (Authentication)：检查请求是否携带有效的 JWT Token。")]),t._v(" "),e("li",[t._v("授权 (Authorization)：检查认证通过的用户是否有权限访问该接口（例如：角色校验 RolesGuard）。")])])]),t._v(" "),e("li",[e("p",[t._v("特点：在中间件之后执行，且可以访问 ExecutionContext（执行上下文），拥有更多的关于当前处理程序的信息。")])])]),t._v(" "),e("h3",{attrs:{id:"拦截器-interceptor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拦截器-interceptor"}},[t._v("#")]),t._v(" 拦截器 (Interceptor)")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("职责：在方法执行前后添加额外的逻辑。它可以在函数执行前、后拦截，甚至可以完全覆盖或延迟函数的执行（例如缓存）。它实现了 AOP（面向切面编程） 的思想。")])]),t._v(" "),e("li",[e("p",[t._v("使用场景：")]),t._v(" "),e("ul",[e("li",[t._v("额外逻辑绑定：如缓存拦截、日志记录。")]),t._v(" "),e("li",[t._v("转换响应：将处理程序返回的数据包装成统一的格式（{ code: 200, data: {}, message: 'success' }）。")]),t._v(" "),e("li",[t._v("转换异常：将方法抛出的异常转换为另一种异常。")]),t._v(" "),e("li",[t._v("扩展函数行为：例如超时处理。")])])]),t._v(" "),e("li",[e("p",[t._v("特点：功能非常强大，是 NestJS 的亮点之一。它可以修改函数返回的结果。")])])]),t._v(" "),e("h3",{attrs:{id:"管道-pipe"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#管道-pipe"}},[t._v("#")]),t._v(" 管道 (Pipe)")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("职责：数据转换和验证。将输入数据转换为所需的格式（如字符串转为整数），并验证输入数据，如果数据不合格则抛出异常。")])]),t._v(" "),e("li",[e("p",[t._v("使用场景：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("验证：使用 class-validator 库验证 DTO（数据传输对象），无效时自动抛出 BadRequestException。")])]),t._v(" "),e("li",[e("p",[t._v("转换：将路径参数 :id 从字符串转换为数字 (ParseIntPipe)。")])])])]),t._v(" "),e("li",[e("p",[t._v("特点：通常用于控制器路由处理程序的参数级别。")])])]),t._v(" "),e("h3",{attrs:{id:"异常过滤器-exception-filter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异常过滤器-exception-filter"}},[t._v("#")]),t._v(" 异常过滤器 (Exception Filter)")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("职责：捕获和处理应用程序中抛出的异常。它是整个请求处理链的“最终错误处理程序”。")])]),t._v(" "),e("li",[e("p",[t._v("使用场景：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("捕获未被处理的异常，并返回一个用户友好的错误响应。")])]),t._v(" "),e("li",[e("p",[t._v("自定义错误响应的格式。")])]),t._v(" "),e("li",[e("p",[t._v("记录错误日志。")])])])]),t._v(" "),e("li",[e("p",[t._v("特点：它不预防错误，而是响应错误。可以全局应用，也可以应用于特定的控制器或路由。")])])]),t._v(" "),e("h3",{attrs:{id:"请求流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求流程"}},[t._v("#")]),t._v(" 请求流程")]),t._v(" "),e("p",[t._v("可以把 NestJS 处理请求的过程想象成一个洋葱模型（Onion Model），请求从外一层层进入，响应则从内一层层返回")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/img/frontEnd/nestjsRequestHandler.svg")}})])}),[],!1,null,null,null);e.default=_.exports}}]);