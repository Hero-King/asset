## 数据结构
参考: 我的第一本算法书.pdf
- 哈希表存储的是由键（key）和值（value）组成的数据。
线性查询的缺点: 数据量越多，线性查找耗费的时间就越长。
    由此可知 ：由于数据的查询较为耗时，所以此处并不适合使用数组来存储数据。但使用哈希表便可以解决这个问题。这次我们用5个箱子的数组来存储数据。
使用哈希函数（Hash）计算 Item的键,也就是哈希值,将得到的哈希值除以数组的长度5，求得其余数,结巴数据放到数组的余数位置,如果出现冲突(另一个数据的哈希值%5得到的位置已经有元素了),使用链表,在其后存储数据
查询数据(key="wang"): 
    现根据哈希算法就算出哈希值,得到存再数组里面的位置,在在链表中去线性查找key是wang的数据
哈希冲突解决: 链地址法/开放地址法/

- 堆: 是一种图的树形结构
被用于实现“优先队列”
优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。
堆中的每个结点最多有两个子结点。树的形状取决于数据的个数。另外，结点的排列顺序为从上到下，同一行里则为从左到右。

在堆中存储数据时必须遵守这样一条规则 ：
*子结点必定大于父结点*。因此，最小值被存储在顶端的根结点中。往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端。

取数据: 
取出的是最上面的数据。由于最上面的数据被取出，因此堆的结构也需要重新调整。
将最后的数据（最后一行,最后一个节点）移动到最顶端。
如果子结点的数字小于父结点的，就将父结点与其左右两个子结点中较小的一个进行交换。

解说:
堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都
为 O(1)。
另外，因为取出数据后需要将最后的数据移到最顶端，然后一边比较它与子结点数据
的大小，一边往下移动，所以取出数据需要的运行时间和树的高度成正比。假设数据量为
n，根据堆的形状特点可知树的高度为 log2n ，那么重构树的时间复杂度便为 O(logn)。
添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大
小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度
成正比，也是 O(logn)。

- 二叉查找树
数据存储于二叉查找树的各个结点中。
二叉查找树有两个性质。
第一个是每个结点的值均大于其左子树上任意一个结点的值。
第二个是每个结点的值均小于其右子树上任意一个结点的值。
<img src="img/二叉查找树.jpg" width="50vw" height="50vh"/>
根据这两个性质可以得到以下结论。首先，二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。
反过来，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。

添加数据:
顶端结点开始寻找添加数字的位置。
依次往下比较,得到位置

删除数据:
删除的节点下面没节点
删除的节点下面一个节点
删除的节点下面两个节点 左右子树重新梳理数据

解说:
我们可以把二叉查找树当作是二分查找算法思想的树形结构体现（二分查找的详细
说明在 3-2 节）。因为它具有前面提到的那两个性质，所以在查找数据或寻找适合添加
数据的位置时，只要将其和现有的数据比较大小，就可以根据比较结果得知该往哪边移
动了。
比较的次数取决于树的高度。所以如果结点数为 n，而且树的形状又较为均衡的话，
比较大小和移动的次数最多就是 log2n。因此，时间复杂度为 O(logn)。但是，如果树的
形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了 O(n)。



